var documenterSearchIndex = {"docs":
[{"location":"guide/#guide","page":"Usage Guide","title":"Usage Guide","text":"","category":"section"},{"location":"guide/#Intervals","page":"Usage Guide","title":"Intervals","text":"Intervals represent bounded temporal domains. The simplest form is a NakedInterval, which wraps a (start, stop) tuple:\n\nint = NakedInterval((0.0, 10.0))\nbounds(int)    # (0.0, 10.0)\nmeasure(int)   # 10.0\nmidpoint(int)  # 5.0\n\nYou can also construct one from two arguments:\n\nNakedInterval(0.0, 10.0)","category":"section"},{"location":"guide/#Marked-Intervals","page":"Usage Guide","title":"Marked Intervals","text":"MarkedInterval attaches arbitrary metadata to an interval:\n\ntrial = MarkedInterval((0.0, 5.0), \"stimulus_A\")\nget_mark(trial)   # \"stimulus_A\"\nbounds(trial)      # (0.0, 5.0)\nmeasure(trial)     # 5.0\n\nMarks can be any type — strings, numbers, symbols, or custom structs.","category":"section"},{"location":"guide/#Relative-Intervals","page":"Usage Guide","title":"Relative Intervals","text":"RelativeInterval expresses an interval in coordinates relative to a reference interval. This is useful for defining peri-event windows (e.g., \"100 ms before to 300 ms after stimulus onset\"):\n\nreference = NakedInterval((5.0, 8.0))\nrel = RelativeInterval(reference, true, NakedInterval((-1.0, 3.0)))\nbounds(rel)  # (4.0, 8.0) — anchored to the left edge of reference\n\nThe anchored_left flag controls whether offsets are relative to the start or end of the reference.","category":"section"},{"location":"guide/#Interval-Sets","page":"Usage Guide","title":"Interval Sets","text":"IntervalSet groups contiguous intervals into a single object. The intervals must touch (no gaps) and be ordered:\n\niset = IntervalSet(NakedInterval((0.0, 5.0)), MarkedInterval((5.0, 10.0), :stim))\nbounds(iset)    # (0.0, 10.0)\nmeasure(iset)   # 10.0\nget_mark(iset)  # :stim — returns the mark of the first marked interval","category":"section"},{"location":"guide/#Interval-Operations","page":"Usage Guide","title":"Interval Operations","text":"Complement — find the portions of a domain not covered by an interval or set of intervals:\n\ndomain = NakedInterval((0.0, 10.0))\nstim = NakedInterval((3.0, 7.0))\nbaseline = complement(domain, stim)\n# [NakedInterval((0.0, 3.0)), NakedInterval((7.0, 10.0))]\n\ncomplement also accepts a vector of intervals:\n\nstims = [NakedInterval((2.0, 4.0)), NakedInterval((6.0, 8.0))]\ngaps = complement(domain, stims)\n# [NakedInterval((0.0, 2.0)), NakedInterval((4.0, 6.0)), NakedInterval((8.0, 10.0))]\n\nChunking — break an interval into fixed-size pieces:\n\nchunks = chunk(NakedInterval((0.0, 10.0)), 3.0)\n# [NakedInterval((0.0, 3.0)), NakedInterval((3.0, 6.0)),\n#  NakedInterval((6.0, 9.0)), NakedInterval((9.0, 10.0))]\n\nPass exact=true to drop any remainder that is shorter than chunk_len:\n\nchunks = chunk(NakedInterval((0.0, 10.0)), 3.0, true)\n# [NakedInterval((0.0, 3.0)), NakedInterval((3.0, 6.0)), NakedInterval((6.0, 9.0))]\n\nChunking also works on a vector of intervals, concatenating the results:\n\nchunk([NakedInterval((0.0, 5.0)), NakedInterval((10.0, 15.0))], 2.5)\n\nShrinking — contract an interval inward from both ends:\n\nshrink(NakedInterval((0.0, 10.0)), 2.0)\n# NakedInterval((1.0, 9.0))\n\nWhen applied to a vector, intervals too short to survive the shrink are dropped.\n\nShifting — translate an interval by an offset:\n\nshift_interval(NakedInterval((0.0, 5.0)), 10.0)\n# NakedInterval((10.0, 15.0))\n\nshift_interval preserves marks on MarkedInterval and also works as a curried function:\n\nshifter = shift_interval(10.0)\nshifter(NakedInterval((0.0, 5.0)))  # NakedInterval((10.0, 15.0))\n\nOverlap depth — compute how many intervals overlap at each position:\n\nintervals = [NakedInterval((0.0, 5.0)),\n             NakedInterval((3.0, 8.0)),\n             NakedInterval((6.0, 10.0))]\nlevels = interval_levels(intervals)\n\ninterval_levels returns a vector of MarkedInterval{Float64,Int} where the mark is the overlap count. Assumes input is sorted by start time.\n\nIntersection and subintervals — find overlapping regions:\n\ninterval_intersect(NakedInterval((0.0, 5.0)), NakedInterval((3.0, 8.0)))\n# NakedInterval((3.0, 5.0))\n\n# Pairwise intersections between two sorted, non-overlapping vectors\ninterval_intersections([NakedInterval((0.0, 5.0)), NakedInterval((7.0, 10.0))],\n                       [NakedInterval((3.0, 8.0))])\n# [NakedInterval((3.0, 5.0)), NakedInterval((7.0, 8.0))]\n\nsubinterval validates that one interval is contained in another:\n\nsubinterval(NakedInterval((0.0, 10.0)), NakedInterval((2.0, 8.0)))\n# NakedInterval((2.0, 8.0)) — validated as a subinterval\n\nRelative coordinates — express an interval relative to a reference:\n\nrelative_interval(NakedInterval((5.0, 8.0)), NakedInterval((4.0, 10.0)))\n\nOther utilities:\n\ncheck_overlap(NakedInterval((0.0, 5.0)), NakedInterval((3.0, 8.0)))  # true\nis_subinterval(NakedInterval((2.0, 4.0)), NakedInterval((0.0, 10.0)))  # true\n5.0 in NakedInterval((0.0, 10.0))  # true","category":"section"},{"location":"guide/#Points","page":"Usage Guide","title":"Points","text":"","category":"section"},{"location":"guide/#NakedPoints","page":"Usage Guide","title":"NakedPoints","text":"NakedPoints stores a sorted vector of timestamps on a defined interval:\n\nspikes = NakedPoints([0.5, 1.3, 2.1, 4.7, 5.2, 8.0, 9.1], NakedInterval((0.0, 10.0)))\n\nThe constructor validates that points are sorted and fall within the interval. If not sorted, it will sort them:\n\n# Unsorted input — automatically sorted\nspikes = NakedPoints([9.1, 0.5, 4.7, 2.1, 1.3, 8.0, 5.2], NakedInterval((0.0, 10.0)))\n\nYou can also construct from a tuple or two numbers for the interval bounds:\n\nNakedPoints([1.0, 2.0, 3.0], (0.0, 5.0))\nNakedPoints([1.0, 2.0, 3.0], 0.0, 5.0)\n\nOr let the interval be inferred from the data:\n\nNakedPoints([1.0, 2.0, 3.0])  # interval = (1.0, 3.0)\n\nBasic queries:\n\ncount(spikes)           # 7\nduration(spikes)        # 10.0\nrate(spikes)            # 0.7 (count / duration)\nbounds(spikes)          # (0.0, 10.0)\ninterval(spikes)        # NakedInterval((0.0, 10.0))\n\n# Count and rate within a sub-range\ncount(spikes, 2.0, 6.0)   # 3\nrate(spikes, 2.0, 6.0)    # 0.75\n\nExtracting values:\n\npoint_values(spikes)           # the underlying vector\npoint_values(spikes, 2.0, 6.0) # view of values in [2.0, 6.0]\nnakedvalues(spikes)            # same as point_values for NakedPoints\n\nTranslation — shift all points and their interval by a constant offset:\n\nshifted = translate(spikes, 100.0)\nbounds(shifted)  # (100.0, 110.0)","category":"section"},{"location":"guide/#VariablePoints","page":"Usage Guide","title":"VariablePoints","text":"VariablePoints pairs each timestamp with a mark (metadata value). Construct from a NakedPoints and a marks vector:\n\nnp = NakedPoints([1.0, 2.0, 3.0], NakedInterval((0.0, 5.0)))\nvp = VariablePoints(np, [:a, :b, :c])\n\nIndividual elements are MarkedPoint objects:\n\nvp[1]  # MarkedPoint(1.0, :a)\n\nExtracting values and marks:\n\npoint_values(vp)            # (times_vector, marks_vector)\npoint_values(vp, 1.0, 2.5)  # (view of times, view of marks) in range\nget_mark(vp)                 # the full marks vector\n\nAll Points operations (count, rate, duration, bounds, translate) work on VariablePoints.","category":"section"},{"location":"guide/#SubPoints","page":"Usage Guide","title":"SubPoints","text":"SubPoints is a lazy, zero-copy view of a Points collection restricted to a sub-interval:\n\nspikes = NakedPoints([0.5, 1.3, 2.1, 4.7, 5.2, 8.0, 9.1], NakedInterval((0.0, 10.0)))\ntrial = SubPoints(spikes, NakedInterval((2.0, 6.0)))\n\ncount(trial)     # 3 — only points in [2.0, 6.0]\nrate(trial)      # 0.75\nduration(trial)  # 4.0\n\nThe constructor validates that the sub-interval is contained within the parent:\n\nSubPoints(spikes, NakedInterval((2.0, 6.0)))  # OK\nSubPoints(spikes, (2.0, 6.0))                  # tuple form also works\nSubPoints(spikes, 2.0, 6.0)                    # two-argument form\n\nNesting SubPoints flattens automatically — the inner view references the original data, not the intermediate view.\n\nmaybe_subpoints returns a SubPoints if the interval intersects, or nothing if it doesn't:\n\nmaybe_subpoints(spikes, NakedInterval((2.0, 6.0)))   # SubPoints(...)\nmaybe_subpoints(spikes, NakedInterval((20.0, 30.0)))  # nothing","category":"section"},{"location":"guide/#Mark-Operations","page":"Usage Guide","title":"Mark Operations","text":"Marks can be stacked and unstacked using tuple nesting:\n\np = NakedPoint(1.0)\nmp = push_mark(p, :neuron_A)      # MarkedPoint(1.0, :neuron_A)\nmp2 = push_mark(mp, 42)           # MarkedPoint(1.0, (42, :neuron_A))\ninner, outer_mark = pop_mark(mp2)  # (MarkedPoint(1.0, (:neuron_A,)), 42)\n\npop_marks strips the outermost mark from all points in a VariablePoints.","category":"section"},{"location":"guide/#Joining-Points","page":"Usage Guide","title":"Joining Points","text":"join_points merges multiple point collections. The result's interval is the union of the inputs:\n\na = NakedPoints([1.0, 3.0], NakedInterval((0.0, 5.0)))\nb = NakedPoints([2.0, 7.0], NakedInterval((0.0, 10.0)))\njoined = join_points(a, b)\n# 4 points on interval (0.0, 10.0), sorted\n\nWorks for both naked and marked points, and accepts any number of arguments:\n\njoin_points(a, b, c)  # merges three collections","category":"section"},{"location":"guide/#Intersecting-Point-Collections","page":"Usage Guide","title":"Intersecting Point Collections","text":"points_intersects finds the intersection of two vectors of Points — restricting each collection to only the time ranges where both have coverage:\n\npts1 = [NakedPoints([1.0, 2.0], NakedInterval((0.0, 5.0)))]\npts2 = [NakedPoints([3.0, 6.0], NakedInterval((2.0, 8.0)))]\nsub1, sub2 = points_intersects(pts1, pts2)\n\ninterval_intersections_subpoints is the lower-level function that intersects a vector of Points with a vector of Interval objects, returning SubPoints views.","category":"section"},{"location":"guide/#Downsampling","page":"Usage Guide","title":"Downsampling","text":"pp_downsamp merges points that are closer together than a given resolution, useful for reducing dense event data for visualization:\n\nspikes = NakedPoints([1.0, 1.1, 1.2, 5.0, 5.05, 9.0], NakedInterval((0.0, 10.0)))\nds = pp_downsamp(spikes, 0.0, 10.0, 0.5)\n\nPoints within resolution of each other are merged using a merge function. The default pt_merge averages timestamps (and marks, if present). pt_extent_merge preserves the extent (min, max) of merged points as an additional mark.\n\nEach merged point gets a count pushed onto its mark stack, recording how many original points were combined.","category":"section"},{"location":"guide/#Aggregate-Rate","page":"Usage Guide","title":"Aggregate Rate","text":"rate can also be computed over a vector of Points:\n\nrate([trial_spikes_1, trial_spikes_2, trial_spikes_3])\n# total spike count across all trials / total duration","category":"section"},{"location":"api/#api","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#EventIntervals.EventIntervals","page":"API Reference","title":"EventIntervals.EventIntervals","text":"EventIntervals\n\nInterval-aware data structures for point processes. Couples timestamped event collections (Points) with the temporal domains (Interval) they are defined on, so that slicing, intersecting, downsampling, and transforming operations keep points and their intervals in sync.\n\nCore types come in \"naked\" (coordinates only) and \"marked\" (coordinates + metadata) variants: NakedPoint/MarkedPoint, NakedInterval/MarkedInterval, NakedPoints/VariablePoints. SubPoints provides lazy, zero-copy views into any points collection.\n\n\n\n\n\n","category":"module"},{"location":"api/#EventIntervals.Interval","page":"API Reference","title":"EventIntervals.Interval","text":"Interval{E,N}\n\nAbstract supertype for interval types, parameterised by the element type E and dimensionality N. All concrete subtypes must implement bounds returning an NTuple{2,E}.\n\nSupports in membership testing, measure, midpoint, bounds, and nakedinterval.\n\n\n\n\n\n","category":"type"},{"location":"api/#EventIntervals.IntervalSet","page":"API Reference","title":"EventIntervals.IntervalSet","text":"IntervalSet{E,T} <: Interval{E,1}\n\nA composite interval formed from a tuple of contiguous, ordered sub-intervals. Behaves as a single interval whose bounds span from the start of the first component to the end of the last.\n\nConstructors\n\nIntervalSet(i1::Interval, i2::Interval, ...)\nIntervalSet(intervals::AbstractVector{<:Interval})\nIntervalSet(intervals::NTuple{N,Interval})\n\nThrows ArgumentError if the intervals are not contiguous (each must start where the previous one ends) or if the collection is empty.\n\nSee also get_mark.\n\n\n\n\n\n","category":"type"},{"location":"api/#EventIntervals.MarkedInterval","page":"API Reference","title":"EventIntervals.MarkedInterval","text":"MarkedInterval{D<:Number,M} <: Interval{D,1}\n\nAn interval with attached metadata of type M. The mark can be any type.\n\nConstructors\n\nMarkedInterval(interval::NakedInterval, mark)\nMarkedInterval((a, b), mark)\nMarkedInterval(a, b, mark)\n\nSee also get_mark, nakedinterval.\n\n\n\n\n\n","category":"type"},{"location":"api/#EventIntervals.MarkedPoint","page":"API Reference","title":"EventIntervals.MarkedPoint","text":"MarkedPoint{E,M} <: Point{E}\n\nA timestamp of type E paired with a mark of type M. Marks can be any type — numbers, symbols, tuples, or custom structs.\n\nSee also push_mark, pop_mark.\n\n\n\n\n\n","category":"type"},{"location":"api/#EventIntervals.MarkedPoints","page":"API Reference","title":"EventIntervals.MarkedPoints","text":"MarkedPoints{E,N,I,M}\n\nType alias for Points{E,N,I,MarkedPoint{E,M}} — any Points collection whose elements are MarkedPoint values.\n\n\n\n\n\n","category":"type"},{"location":"api/#EventIntervals.NakedInterval","page":"API Reference","title":"EventIntervals.NakedInterval","text":"NakedInterval{D<:Number} <: Interval{D,1}\n\nA plain interval storing (start, stop) bounds with no metadata. The fundamental interval type in EventIntervals.\n\nConstructors\n\nNakedInterval((a, b))\nNakedInterval(a, b)\n\nArguments are promoted to a common numeric type.\n\n\n\n\n\n","category":"type"},{"location":"api/#EventIntervals.NakedPoint","page":"API Reference","title":"EventIntervals.NakedPoint","text":"NakedPoint{E} <: Point{E}\n\nA bare timestamp with no metadata. Wraps a single value of type E.\n\n\n\n\n\n","category":"type"},{"location":"api/#EventIntervals.NakedPoints","page":"API Reference","title":"EventIntervals.NakedPoints","text":"NakedPoints{E,I,A} <: Points{E,1,I,NakedPoint{E}}\n\nA sorted vector of timestamps of type E defined on an interval of type I. Points need not be strictly increasing, but must be non-decreasingly sorted.\n\nConstructors\n\nNakedPoints(points::AbstractVector{E}, interval::Interval{E})\nNakedPoints(points::AbstractVector{E}, (a, b))\nNakedPoints(points::AbstractVector{E}, a, b)\nNakedPoints(points::AbstractVector)\n\nThe first three forms accept an explicit interval; unsorted input is sorted in-place. The last form infers the interval from (minimum(points), maximum(points)) and requires a non-empty vector.\n\nThrows ArgumentError if points fall outside the given interval.\n\n\n\n\n\n","category":"type"},{"location":"api/#EventIntervals.Point","page":"API Reference","title":"EventIntervals.Point","text":"Point{E}\n\nAbstract supertype for timestamped event types, parameterised by the element type E of the timestamp. Concrete subtypes are NakedPoint and MarkedPoint.\n\nPoint values support isless comparison with Number values, delegating to nakedpointvalue.\n\n\n\n\n\n","category":"type"},{"location":"api/#EventIntervals.Points","page":"API Reference","title":"EventIntervals.Points","text":"Points{E,N,I<:Interval{E},T<:Point{E}} <: AbstractVector{T}\n\nAbstract supertype for read-only collections of Point values defined on an Interval. Subtypes are NakedPoints, VariablePoints, and SubPoints.\n\nPoints implements AbstractVector, so indexing, iteration, and length work as expected. Assignment via setindex! throws ReadOnlyMemoryError.\n\n\n\n\n\n","category":"type"},{"location":"api/#EventIntervals.RelativeInterval","page":"API Reference","title":"EventIntervals.RelativeInterval","text":"RelativeInterval{D,I,J} <: Interval{D,1}\n\nAn interval expressed in coordinates relative to a reference interval. Useful for defining peri-event windows (e.g. \"100 ms before to 300 ms after stimulus onset\").\n\nRelativeInterval(reference::Interval, anchored_left::Bool, offset::Interval)\n\nIf anchored_left is true, offsets are relative to the start of reference; if false, relative to the end.\n\nbounds resolves to absolute coordinates by adding the anchor point.\n\n\n\n\n\n","category":"type"},{"location":"api/#EventIntervals.SubPoints","page":"API Reference","title":"EventIntervals.SubPoints","text":"SubPoints{E,M,I,P} <: Points{E,1,I,M}\n\nA lazy, zero-copy view of a Points collection restricted to a sub-interval. Indexing uses a precomputed offset for O(1) element access.\n\nConstructors\n\nSubPoints(points::Points, interval::Interval)\nSubPoints(points::Points, (a, b))\nSubPoints(points::Points, a, b)\n\nThe sub-interval must be contained within interval(points) (throws ArgumentError otherwise). Nesting SubPoints inside another SubPoints flattens automatically, referencing the original underlying data.\n\nSee also maybe_subpoints.\n\n\n\n\n\n","category":"type"},{"location":"api/#EventIntervals.VariablePoints","page":"API Reference","title":"EventIntervals.VariablePoints","text":"VariablePoints{E,I,P,M,A} <: Points{E,1,I,MarkedPoint{E,M}}\n\nA sorted collection of timestamps paired with per-point marks of type M. Wraps a NakedPoints for the timestamps and a separate marks vector.\n\nConstructors\n\nVariablePoints(nakedpoints::NakedPoints, marks::AbstractVector)\nVariablePoints(points::AbstractVector, marks::AbstractVector, interval_args...)\nVariablePoints(pts::AbstractVector{<:MarkedPoint}, interval_args...)\n\nThe second form sorts points and permutes marks to match. The third form destructures MarkedPoint elements. All forms require length(points) == length(marks).\n\nSee also get_mark, point_values.\n\n\n\n\n\n","category":"type"},{"location":"api/#EventIntervals.bounds-Tuple{NakedInterval}","page":"API Reference","title":"EventIntervals.bounds","text":"bounds(m::Interval) -> NTuple{2,E}\nbounds(p::Points) -> NTuple{2,E}\n\nReturn the (start, stop) bounds of an interval or points collection.\n\n\n\n\n\n","category":"method"},{"location":"api/#EventIntervals.chunk-Union{Tuple{E}, Tuple{Interval{E, 1}, E}, Tuple{Interval{E, 1}, E, Bool}} where E","page":"API Reference","title":"EventIntervals.chunk","text":"chunk(int::Interval{E,1}, chunk_len::E, exact::Bool=false) where E -> Vector{NakedInterval{E}}\n\nBreak int into consecutive sub-intervals of length chunk_len. If exact is true, any trailing remainder shorter than chunk_len is dropped; otherwise it is included as the final chunk.\n\nchunk_len must be positive (throws ArgumentError otherwise).\n\nchunk(intervals::AbstractVector{<:Interval{E,1}}, chunk_len::E, exact::Bool=true) where E\n\nApply chunking to each interval in the vector and concatenate the results.\n\n\n\n\n\n","category":"method"},{"location":"api/#EventIntervals.complement-Union{Tuple{E}, Tuple{Interval{E}, Interval}} where E","page":"API Reference","title":"EventIntervals.complement","text":"complement(dom::Interval, int::Interval) -> Vector{NakedInterval}\ncomplement(dom::Interval, ints::AbstractVector{<:Interval}) -> Vector{NakedInterval}\n\nReturn the portions of dom not covered by int (or by any interval in ints). The vector form requires ints to be sorted by start time.\n\n\n\n\n\n","category":"method"},{"location":"api/#EventIntervals.get_mark-Tuple{MarkedInterval}","page":"API Reference","title":"EventIntervals.get_mark","text":"get_mark(m::MarkedInterval)\nget_mark(iset::IntervalSet)\nget_mark(vp::VariablePoints)\nget_mark(sp::SubPoints)\n\nRetrieve the mark from a marked object. For an IntervalSet, returns the mark of the first MarkedInterval component. For VariablePoints or marked SubPoints, returns the marks vector.\n\nThrows an error if no mark is found.\n\n\n\n\n\n","category":"method"},{"location":"api/#EventIntervals.interval-Tuple{Points}","page":"API Reference","title":"EventIntervals.interval","text":"interval(p::Points) -> Interval\n\nReturn the domain interval on which the points collection is defined.\n\n\n\n\n\n","category":"method"},{"location":"api/#EventIntervals.interval_intersections_subpoints-Union{Tuple{P}, Tuple{M}, Tuple{E}, Tuple{AbstractVector{P}, AbstractVector{<:Interval{E}}}} where {E, M, P<:(Points{E, 1, <:Any, M})}","page":"API Reference","title":"EventIntervals.interval_intersections_subpoints","text":"interval_intersections_subpoints(points::AbstractVector{<:Points}, intervals::AbstractVector{<:Interval}) -> Vector{SubPoints}\n\nFor each overlap between a points collection in points and an interval in intervals, produce a SubPoints view. Both inputs must be sorted by start time.\n\nThis is the lower-level function behind points_intersects.\n\n\n\n\n\n","category":"method"},{"location":"api/#EventIntervals.interval_levels-Union{Tuple{AbstractVector{<:Interval{E, 1}}}, Tuple{E}} where E","page":"API Reference","title":"EventIntervals.interval_levels","text":"interval_levels(intervals::AbstractVector{<:Interval{E,1}}) where E -> Vector{MarkedInterval{E,Int}}\n\nPartition the time axis into segments labelled by the depth of interval overlap. Returns a vector of MarkedInterval where each mark is the number of input intervals overlapping that segment.\n\nintervals must be sorted by start time and non-empty (throws ArgumentError otherwise).\n\n\n\n\n\n","category":"method"},{"location":"api/#EventIntervals.join_points-Union{Tuple{Points{<:Any, <:Any, <:Any, P}}, Tuple{P}} where P<:NakedPoint","page":"API Reference","title":"EventIntervals.join_points","text":"join_points(pt::Points) -> NakedPoints or VariablePoints\njoin_points(pt1::Points, pt2::Points, pts::Points...) -> NakedPoints or VariablePoints\n\nMaterialise or merge point collections. The single-argument form copies a (possibly lazy) Points into a concrete NakedPoints or VariablePoints. The multi-argument form concatenates points and sorts the result; the output interval is the union of all input intervals. All arguments must have the same point type (all naked or all marked).\n\n\n\n\n\n","category":"method"},{"location":"api/#EventIntervals.maybe_subpoints-Tuple{Points, Interval}","page":"API Reference","title":"EventIntervals.maybe_subpoints","text":"maybe_subpoints(points::Points, i::Interval) -> SubPoints or nothing\n\nReturn a SubPoints view if i overlaps with the domain of points, or nothing if there is no intersection.\n\n\n\n\n\n","category":"method"},{"location":"api/#EventIntervals.nakedinterval-Tuple{Interval}","page":"API Reference","title":"EventIntervals.nakedinterval","text":"nakedinterval(i::Interval) -> NakedInterval\nnakedinterval(p::Points) -> NakedInterval\n\nStrip any mark or wrapper to obtain a plain NakedInterval. Identity on NakedInterval inputs.\n\n\n\n\n\n","category":"method"},{"location":"api/#EventIntervals.nakedpoints-Tuple{NakedPoints}","page":"API Reference","title":"EventIntervals.nakedpoints","text":"nakedpoints(p::Points) -> NakedPoints\n\nExtract or return the underlying NakedPoints (timestamps only, no marks). Identity on NakedPoints inputs. For SubPoints, materialises a new NakedPoints covering the sub-interval.\n\n\n\n\n\n","category":"method"},{"location":"api/#EventIntervals.nakedpointvalue-Tuple{NakedPoint}","page":"API Reference","title":"EventIntervals.nakedpointvalue","text":"nakedpointvalue(pt::Point) -> E\n\nReturn the raw timestamp value from a Point.\n\n\n\n\n\n","category":"method"},{"location":"api/#EventIntervals.nakedvalues-Tuple{Points, Any, Any}","page":"API Reference","title":"EventIntervals.nakedvalues","text":"nakedvalues(p::Points) -> AbstractVector\nnakedvalues(p::Points, b, e) -> AbstractVector\n\nReturn the raw timestamp values from a points collection, stripping any marks. Equivalent to point_values(nakedpoints(p), ...).\n\n\n\n\n\n","category":"method"},{"location":"api/#EventIntervals.point_values-Tuple{AbstractVector{<:NakedPoint}}","page":"API Reference","title":"EventIntervals.point_values","text":"point_values(pts)\n\nExtract the underlying value arrays from a collection of points.\n\nFor a vector of NakedPoint, returns a vector of timestamps. For a vector of MarkedPoint, returns (timestamps, marks). For Points subtypes, see NakedPoints, VariablePoints, and SubPoints for range-query forms point_values(pts, b, e).\n\n\n\n\n\n","category":"method"},{"location":"api/#EventIntervals.points-Union{Tuple{M}, Tuple{Points{<:Any, <:Any, <:Any, M}, Vararg{Any}}} where M","page":"API Reference","title":"EventIntervals.points","text":"points(p::Points, [b, e]) -> Vector{<:Point}\n\nMaterialise the Point objects from a points collection. The optional range [b, e] restricts to points within those bounds.\n\n\n\n\n\n","category":"method"},{"location":"api/#EventIntervals.points_intersects-Tuple{AbstractVector{<:Points}, AbstractVector{<:Points}}","page":"API Reference","title":"EventIntervals.points_intersects","text":"points_intersects(pts1::AbstractVector{<:Points}, pts2::AbstractVector{<:Points}) -> (Vector{SubPoints}, Vector{SubPoints})\n\nRestrict two vectors of Points to only the time ranges where both have coverage. Returns a pair of SubPoints vectors aligned to the same intersection intervals. Both inputs must be sorted by start time.\n\nSee also interval_intersections_subpoints.\n\n\n\n\n\n","category":"method"},{"location":"api/#EventIntervals.pop_mark-Tuple{MarkedPoint{<:Any, <:Tuple}}","page":"API Reference","title":"EventIntervals.pop_mark","text":"pop_mark(mp::MarkedPoint{<:Any,<:Tuple}) -> (MarkedPoint, mark)\n\nRemove the outermost mark from a tuple-marked MarkedPoint, returning the modified point and the removed mark. If the mark tuple is empty, returns (mp, nothing).\n\nSee also push_mark, pop_marks.\n\n\n\n\n\n","category":"method"},{"location":"api/#EventIntervals.pop_marks-Tuple{VariablePoints}","page":"API Reference","title":"EventIntervals.pop_marks","text":"pop_marks(p::VariablePoints) -> VariablePoints\n\nStrip the outermost element from tuple marks on all points. Each mark (a, b) becomes b. This is the collection-level counterpart of pop_mark and is useful for removing the merge-count mark added by pp_downsamp.\n\n\n\n\n\n","category":"method"},{"location":"api/#EventIntervals.pp_downsamp-Union{Tuple{RetType}, Tuple{M}, Tuple{E}, Tuple{Points{E, 1, <:Any, M}, Any, Any, Any}, Tuple{Points{E, 1, <:Any, M}, Any, Any, Any, Function}, Tuple{Points{E, 1, <:Any, M}, Any, Any, Any, Function, Type{RetType}}} where {E, M, RetType}","page":"API Reference","title":"EventIntervals.pp_downsamp","text":"pp_downsamp(p::Points, b, e, resolution, [merge_func=pt_merge], [RetType=eltype(p)]) -> VariablePoints\n\nDownsample points within [b, e] by merging consecutive points closer than resolution. Adjacent points whose gap is less than resolution are merged using merge_func. Each merged point receives a count mark (via push_mark) recording how many original points were combined.\n\nThe default merge_func is pt_merge (mean of timestamps and marks). RetType specifies the return type of merge_func for type stability.\n\nSee also pt_merge, pt_extent_merge, pop_marks.\n\n\n\n\n\n","category":"method"},{"location":"api/#EventIntervals.pt_extent_merge-Tuple{AbstractVector{<:MarkedPoint{<:Number, <:Number}}}","page":"API Reference","title":"EventIntervals.pt_extent_merge","text":"pt_extent_merge(pts::AbstractVector{<:MarkedPoint}) -> MarkedPoint\npt_extent_merge(pts::AbstractVector{<:NakedPoint}) -> MarkedPoint\n\nMerge a group of points by averaging timestamps and recording the extent (min, max). For MarkedPoint inputs, returns MarkedPoint(mean_time, ((min_time, max_time), mean_mark)). For NakedPoint inputs, returns MarkedPoint(mean_time, (min_time, max_time)).\n\nAlternative merge function for pp_downsamp.\n\n\n\n\n\n","category":"method"},{"location":"api/#EventIntervals.pt_merge-Tuple{AbstractVector{<:NakedPoint{<:Number}}}","page":"API Reference","title":"EventIntervals.pt_merge","text":"pt_merge(pts::AbstractVector{<:NakedPoint}) -> NakedPoint\npt_merge(pts::AbstractVector{<:MarkedPoint}) -> MarkedPoint\n\nMerge a group of points by averaging their timestamps (and marks, for MarkedPoint). Used as the default merge function in pp_downsamp.\n\n\n\n\n\n","category":"method"},{"location":"api/#EventIntervals.push_mark-Tuple{MarkedPoint, Any}","page":"API Reference","title":"EventIntervals.push_mark","text":"push_mark(p::NakedPoint, mark) -> MarkedPoint\npush_mark(mp::MarkedPoint, newmark) -> MarkedPoint\n\nAdd a mark to a point. On a NakedPoint, creates a MarkedPoint. On a MarkedPoint, nests the new mark into a tuple (newmark, existing_mark), forming a mark stack.\n\nSee also pop_mark.\n\n\n\n\n\n","category":"method"},{"location":"api/#EventIntervals.rate-Tuple{Points}","page":"API Reference","title":"EventIntervals.rate","text":"rate(p::Points) -> Number\nrate(p::Points, b, e) -> Number\nrate(ps::AbstractVector{<:Points}) -> Number or nothing\n\nCompute the event rate (count / duration). The two-argument form restricts the calculation to the range [b, e]. The vector form computes the aggregate rate across all collections, returning nothing if the vector is empty.\n\n\n\n\n\n","category":"method"},{"location":"api/#EventIntervals.shift_interval-Tuple{NakedInterval, Number}","page":"API Reference","title":"EventIntervals.shift_interval","text":"shift_interval(a::Interval, offset::Number) -> Interval\nshift_interval(offset::Number) -> Function\n\nTranslate an interval by adding offset to both bounds. Preserves the mark on a MarkedInterval. The single-argument form returns a curried function.\n\n\n\n\n\n","category":"method"},{"location":"api/#EventIntervals.shrink-Tuple{Interval, Any}","page":"API Reference","title":"EventIntervals.shrink","text":"shrink(int::Interval, shrink_measure) -> Interval\nshrink(ints::AbstractVector{<:Interval}, shrink_measure) -> Vector\n\nContract an interval inward by shrink_measure / 2 from each end. If shrink_measure exceeds the interval's measure, the result is a zero-width interval at the midpoint.\n\nThe vector form drops any intervals whose measure is less than shrink_measure before shrinking the survivors.\n\n\n\n\n\n","category":"method"},{"location":"api/#EventIntervals.subinterval-Tuple{Interval, Real, Real}","page":"API Reference","title":"EventIntervals.subinterval","text":"subinterval(int::Interval{E,1}, b::Real, e::Real) -> Interval\nsubinterval(int::Interval{E,1}, sub::NakedInterval{E}) -> Interval\n\nReturn the portion of int delimited by [b, e]. Preserves the type and mark of int (e.g. a MarkedInterval yields a MarkedInterval with the same mark).\n\nThrows ArgumentError if [b, e] is not contained within int.\n\n\n\n\n\n","category":"method"},{"location":"api/#EventIntervals.translate-Tuple{NakedPoints, Any}","page":"API Reference","title":"EventIntervals.translate","text":"translate(p::NakedPoints, offset) -> NakedPoints\ntranslate(p::VariablePoints, offset) -> VariablePoints\n\nShift all timestamps and the domain interval by offset. Marks are preserved.\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.duration-Tuple{Points}","page":"API Reference","title":"SignalIndices.duration","text":"duration(p::Points) -> Number\n\nReturn the duration (measure) of the domain interval. Equivalent to measure(interval(p)).\n\n\n\n\n\n","category":"method"},{"location":"api/#SignalIndices.time_interval-Tuple{Points}","page":"API Reference","title":"SignalIndices.time_interval","text":"time_interval(p::Points) -> Interval\n\nReturn the domain interval. Synonym for interval.\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.check_overlap-Tuple{Interval, Interval}","page":"API Reference","title":"SortedIntervals.check_overlap","text":"check_overlap(m::Interval, n::Interval) -> Bool\n\nReturn true if intervals m and n overlap (share at least one point).\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.interval_indices-Tuple{Any, Interval}","page":"API Reference","title":"SortedIntervals.interval_indices","text":"interval_indices(basis, i::Interval)\ninterval_indices(basis, a::AbstractVector{<:Interval})\n\nReturn the indices into basis that fall within interval i. The vector form maps over each interval independently.\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.interval_intersect-Tuple{Interval, Interval}","page":"API Reference","title":"SortedIntervals.interval_intersect","text":"interval_intersect(a::Interval, b::Interval) -> NakedInterval or nothing\n\nReturn the intersection of two intervals as a NakedInterval, or nothing if they do not overlap.\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.interval_intersections-Tuple{AbstractVector{<:Interval}, AbstractVector{<:Interval}}","page":"API Reference","title":"SortedIntervals.interval_intersections","text":"interval_intersections(a::AbstractVector{<:Interval}, b::AbstractVector{<:Interval}) -> Vector{NakedInterval}\n\nCompute all pairwise intersections between two sorted vectors of intervals. Both a and b must be sorted by start time.\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.intervals_diff-Tuple{AbstractVector{<:Interval}, Any}","page":"API Reference","title":"SortedIntervals.intervals_diff","text":"intervals_diff(a::AbstractVector{<:Interval}, b) -> Vector{NakedInterval}\nintervals_diff(a, b::AbstractVector{<:Interval}) -> Vector{NakedInterval}\n\nCompute the set difference of two sorted interval vectors: the portions of a not covered by b. Accepts Interval objects or NTuple{2} bounds in either argument position.\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.is_subinterval-Tuple{Interval, Interval}","page":"API Reference","title":"SortedIntervals.is_subinterval","text":"is_subinterval(m::Interval, parent::Interval) -> Bool\n\nReturn true if m is entirely contained within parent (inclusive bounds).\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.mask_events-Tuple{Any, Interval}","page":"API Reference","title":"SortedIntervals.mask_events","text":"mask_events(evts, i::Interval)\n\nFilter a sorted event vector to only those falling within interval i. Delegates to SortedIntervals.mask_events(evts, b, e).\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.maximum_interval_overlap-Tuple{AbstractVector{<:Interval}, Interval}","page":"API Reference","title":"SortedIntervals.maximum_interval_overlap","text":"maximum_interval_overlap(xs::AbstractVector{<:Interval}, y::Interval) -> Number\n\nReturn the maximum overlap (in measure) between any single interval in xs and the interval y.\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.measure-Tuple{Interval}","page":"API Reference","title":"SortedIntervals.measure","text":"measure(m::Interval)\nmeasure(m::IntervalSet)\nmeasure(p::Points)\n\nReturn the length (duration) of an interval. For an IntervalSet, returns the sum of the component measures. For a Points collection, returns the measure of its underlying interval.\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.midpoint-Tuple{Interval}","page":"API Reference","title":"SortedIntervals.midpoint","text":"midpoint(m::Interval)\n\nReturn the midpoint of the interval (b + e) / 2.\n\n\n\n\n\n","category":"method"},{"location":"api/#SortedIntervals.relative_interval-Tuple{Interval, Interval}","page":"API Reference","title":"SortedIntervals.relative_interval","text":"relative_interval(interval, reference) -> NakedInterval\n\nExpress interval in coordinates relative to reference by subtracting the reference start from both bounds. Either argument may be an Interval or an NTuple{2,<:Number}.\n\n\n\n\n\n","category":"method"},{"location":"#EventIntervals.jl","page":"Home","title":"EventIntervals.jl","text":"EventIntervals provides interval-aware data structures for point processes. It couples timestamped event collections with the temporal domains they are defined on, so that slicing, intersecting, downsampling, and transforming operations keep points and their intervals in sync.","category":"section"},{"location":"#Motivation","page":"Home","title":"Motivation","text":"Working with recorded event data — spike trains, behavioral events, stimulus onsets — requires two abstractions that are tightly coupled in practice but rarely coupled in code: collections of timestamped events and the temporal intervals they live on. A spike train is not just a sorted vector of times; it is a sorted vector of times defined on a recording interval, and operations on it (computing a firing rate, windowing to a trial, intersecting with another recording) must respect that domain.\n\nEventIntervals makes this coupling explicit. Every Points object carries its domain interval, and the package provides operations that act on both together: windowing produces a lazy SubPoints view rather than a copy, rate calculations use the interval's measure as the denominator, and joining two point processes produces a result whose interval is the union of the inputs.\n\nThe interval layer is equally first-class. Intervals can carry metadata (MarkedInterval), be expressed in relative coordinates (RelativeInterval), or be grouped into contiguous segments (IntervalSet). Operations like complement, chunking, overlap-depth calculation, and shrinking work on these types directly.","category":"section"},{"location":"#Design-Principles","page":"Home","title":"Design Principles","text":"Points live on intervals. Every Points collection has an associated Interval that defines its temporal domain. Constructors validate that all points fall within their interval, and operations propagate intervals automatically.\n\nNaked and marked variants. Each core type comes in two forms: a lightweight \"naked\" version carrying only coordinates, and a \"marked\" version carrying arbitrary metadata. NakedPoint vs. MarkedPoint, NakedInterval vs. MarkedInterval, NakedPoints vs. VariablePoints. This means zero overhead when you don't need metadata, with a smooth upgrade path when you do.\n\nLazy views over copies. SubPoints provides a zero-copy view of a point collection within a sub-interval, backed by binary search for efficient range queries. This makes repeated windowing operations (e.g., slicing a long recording into hundreds of trial windows) cheap.\n\nImmutable collections. Points types implement AbstractVector but are read-only. This ensures data integrity when multiple SubPoints views reference the same underlying data.\n\nComposable marks. Marks on points can be stacked using tuple nesting via push_mark and pop_mark, allowing metadata to accumulate through processing pipelines (e.g., downsampling pushes a merge count onto each point's mark stack).","category":"section"},{"location":"#Type-Hierarchy","page":"Home","title":"Type Hierarchy","text":"Point{E}\n├── NakedPoint{E}              # bare timestamp\n└── MarkedPoint{E,M}           # timestamp + metadata\n\nInterval{E,N}\n├── NakedInterval{D}           # (start, stop) bounds\n├── MarkedInterval{D,M}        # interval + metadata\n├── RelativeInterval{D,I,J}    # interval in relative coordinates\n└── IntervalSet{E,T}           # contiguous interval segments\n\nPoints{E,N,I,T} <: AbstractVector{T}\n├── NakedPoints{E,I,A}         # sorted timestamps on an interval\n├── VariablePoints{E,I,P,M,A}  # sorted timestamps + per-point marks\n└── SubPoints{E,M,I,P}         # lazy view into another Points","category":"section"},{"location":"#Example-Workflow","page":"Home","title":"Example Workflow","text":"A typical workflow for trial-based neural data analysis:\n\nusing EventIntervals\n\n# Spike times from a 30-second recording\nspikes = NakedPoints([0.5, 1.3, 2.1, 4.7, 5.2, 8.0, 9.1], NakedInterval((0.0, 10.0)))\n\n# Define trial and inter-trial intervals\ntrial = NakedInterval((2.0, 6.0))\nbaseline = complement(interval(spikes), trial)\n\n# View spikes within the trial — no data copied\ntrial_spikes = SubPoints(spikes, trial)\nrate(trial_spikes)  # firing rate within the trial window\n\n# Break a long interval into fixed-size analysis windows\nwindows = chunk(NakedInterval((0.0, 10.0)), 2.5)\n# 4-element Vector{NakedInterval{Float64}}:\n#   (0.0, 2.5), (2.5, 5.0), (5.0, 7.5), (7.5, 10.0)\n\n# Compute overlap depth across a set of intervals\nlevels = interval_levels([NakedInterval((0.0, 5.0)),\n                          NakedInterval((3.0, 8.0)),\n                          NakedInterval((6.0, 10.0))])\n\n# Downsample dense spike trains for visualization\ndownsampled = pp_downsamp(spikes, 0.0, 10.0, 1.0)","category":"section"},{"location":"#Ecosystem-Context","page":"Home","title":"Ecosystem Context","text":"EventIntervals occupies a specific niche in the Julia ecosystem. It is a data manipulation package for observed point process realizations, not a statistical modeling or simulation framework.\n\nPackage Best for\nEventIntervals.jl Manipulating observed event data on temporal intervals\nSortedIntervals.jl Batch set operations on sorted interval lists (used internally)\nIntervalSets.jl Type-safe single-interval representations\nIntervalTrees.jl Repeated queries on large static interval collections\nJumpProcesses.jl Simulating and fitting point process models\n\nPackages like JumpProcesses.jl and PointProcesses.jl define generative models and fit parameters; EventIntervals stores, slices, and transforms the data those models produce or that experiments record. They are complementary: you might simulate with JumpProcesses and analyze the output with EventIntervals, or sort spikes with SpikeSorting.jl and then manage the resulting spike trains with EventIntervals.\n\nSee the Usage Guide for detailed examples, or the API Reference for complete function signatures.","category":"section"}]
}

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · EventIntervals.jl</title><meta name="title" content="API Reference · EventIntervals.jl"/><meta property="og:title" content="API Reference · EventIntervals.jl"/><meta property="twitter:title" content="API Reference · EventIntervals.jl"/><meta name="description" content="Documentation for EventIntervals.jl."/><meta property="og:description" content="Documentation for EventIntervals.jl."/><meta property="twitter:description" content="Documentation for EventIntervals.jl."/><meta property="og:url" content="https://galenlynch.github.io/EventIntervals.jl/api/"/><meta property="twitter:url" content="https://galenlynch.github.io/EventIntervals.jl/api/"/><link rel="canonical" href="https://galenlynch.github.io/EventIntervals.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">EventIntervals.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../guide/">Usage Guide</a></li><li class="is-active"><a class="tocitem" href>API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/galenlynch/EventIntervals.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/galenlynch/EventIntervals.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="api"><a class="docs-heading-anchor" href="#api">API Reference</a><a id="api-1"></a><a class="docs-heading-anchor-permalink" href="#api" title="Permalink"></a></h1><ul><li><a href="#EventIntervals.EventIntervals"><code>EventIntervals.EventIntervals</code></a></li><li><a href="#EventIntervals.Interval"><code>EventIntervals.Interval</code></a></li><li><a href="#EventIntervals.IntervalSet"><code>EventIntervals.IntervalSet</code></a></li><li><a href="#EventIntervals.MarkedInterval"><code>EventIntervals.MarkedInterval</code></a></li><li><a href="#EventIntervals.MarkedPoint"><code>EventIntervals.MarkedPoint</code></a></li><li><a href="#EventIntervals.MarkedPoints"><code>EventIntervals.MarkedPoints</code></a></li><li><a href="#EventIntervals.NakedInterval"><code>EventIntervals.NakedInterval</code></a></li><li><a href="#EventIntervals.NakedPoint"><code>EventIntervals.NakedPoint</code></a></li><li><a href="#EventIntervals.NakedPoints"><code>EventIntervals.NakedPoints</code></a></li><li><a href="#EventIntervals.Point"><code>EventIntervals.Point</code></a></li><li><a href="#EventIntervals.Points"><code>EventIntervals.Points</code></a></li><li><a href="#EventIntervals.RelativeInterval"><code>EventIntervals.RelativeInterval</code></a></li><li><a href="#EventIntervals.SubPoints"><code>EventIntervals.SubPoints</code></a></li><li><a href="#EventIntervals.VariablePoints"><code>EventIntervals.VariablePoints</code></a></li><li><a href="#EventIntervals.bounds-Tuple{NakedInterval}"><code>EventIntervals.bounds</code></a></li><li><a href="#EventIntervals.chunk-Union{Tuple{E}, Tuple{Interval{E, 1}, E}, Tuple{Interval{E, 1}, E, Bool}} where E"><code>EventIntervals.chunk</code></a></li><li><a href="#EventIntervals.complement-Union{Tuple{E}, Tuple{Interval{E}, Interval}} where E"><code>EventIntervals.complement</code></a></li><li><a href="#EventIntervals.get_mark-Tuple{MarkedInterval}"><code>EventIntervals.get_mark</code></a></li><li><a href="#EventIntervals.interval-Tuple{Points}"><code>EventIntervals.interval</code></a></li><li><a href="#EventIntervals.interval_intersections_subpoints-Union{Tuple{P}, Tuple{M}, Tuple{E}, Tuple{AbstractVector{P}, AbstractVector{&lt;:Interval{E}}}} where {E, M, P&lt;:(Points{E, 1, &lt;:Any, M})}"><code>EventIntervals.interval_intersections_subpoints</code></a></li><li><a href="#EventIntervals.interval_levels-Union{Tuple{AbstractVector{&lt;:Interval{E, 1}}}, Tuple{E}} where E"><code>EventIntervals.interval_levels</code></a></li><li><a href="#EventIntervals.join_points-Union{Tuple{Points{&lt;:Any, &lt;:Any, &lt;:Any, P}}, Tuple{P}} where P&lt;:NakedPoint"><code>EventIntervals.join_points</code></a></li><li><a href="#EventIntervals.maybe_subpoints-Tuple{Points, Interval}"><code>EventIntervals.maybe_subpoints</code></a></li><li><a href="#EventIntervals.nakedinterval-Tuple{Interval}"><code>EventIntervals.nakedinterval</code></a></li><li><a href="#EventIntervals.nakedpoints-Tuple{NakedPoints}"><code>EventIntervals.nakedpoints</code></a></li><li><a href="#EventIntervals.nakedpointvalue-Tuple{NakedPoint}"><code>EventIntervals.nakedpointvalue</code></a></li><li><a href="#EventIntervals.nakedvalues-Tuple{Points, Any, Any}"><code>EventIntervals.nakedvalues</code></a></li><li><a href="#EventIntervals.point_values-Tuple{AbstractVector{&lt;:NakedPoint}}"><code>EventIntervals.point_values</code></a></li><li><a href="#EventIntervals.points-Union{Tuple{M}, Tuple{Points{&lt;:Any, &lt;:Any, &lt;:Any, M}, Vararg{Any}}} where M"><code>EventIntervals.points</code></a></li><li><a href="#EventIntervals.points_intersects-Tuple{AbstractVector{&lt;:Points}, AbstractVector{&lt;:Points}}"><code>EventIntervals.points_intersects</code></a></li><li><a href="#EventIntervals.pop_mark-Tuple{MarkedPoint{&lt;:Any, &lt;:Tuple}}"><code>EventIntervals.pop_mark</code></a></li><li><a href="#EventIntervals.pop_marks-Tuple{VariablePoints}"><code>EventIntervals.pop_marks</code></a></li><li><a href="#EventIntervals.pp_downsamp-Union{Tuple{RetType}, Tuple{M}, Tuple{E}, Tuple{Points{E, 1, &lt;:Any, M}, Any, Any, Any}, Tuple{Points{E, 1, &lt;:Any, M}, Any, Any, Any, Function}, Tuple{Points{E, 1, &lt;:Any, M}, Any, Any, Any, Function, Type{RetType}}} where {E, M, RetType}"><code>EventIntervals.pp_downsamp</code></a></li><li><a href="#EventIntervals.pt_extent_merge-Tuple{AbstractVector{&lt;:MarkedPoint{&lt;:Number, &lt;:Number}}}"><code>EventIntervals.pt_extent_merge</code></a></li><li><a href="#EventIntervals.pt_merge-Tuple{AbstractVector{&lt;:NakedPoint{&lt;:Number}}}"><code>EventIntervals.pt_merge</code></a></li><li><a href="#EventIntervals.push_mark-Tuple{MarkedPoint, Any}"><code>EventIntervals.push_mark</code></a></li><li><a href="#EventIntervals.rate-Tuple{Points}"><code>EventIntervals.rate</code></a></li><li><a href="#EventIntervals.shift_interval-Tuple{NakedInterval, Number}"><code>EventIntervals.shift_interval</code></a></li><li><a href="#EventIntervals.shrink-Tuple{Interval, Any}"><code>EventIntervals.shrink</code></a></li><li><a href="#EventIntervals.subinterval-Tuple{Interval, Real, Real}"><code>EventIntervals.subinterval</code></a></li><li><a href="#EventIntervals.translate-Tuple{NakedPoints, Any}"><code>EventIntervals.translate</code></a></li><li><a href="#SignalIndices.duration-Tuple{Points}"><code>SignalIndices.duration</code></a></li><li><a href="#SignalIndices.time_interval-Tuple{Points}"><code>SignalIndices.time_interval</code></a></li><li><a href="#SortedIntervals.check_overlap-Tuple{Interval, Interval}"><code>SortedIntervals.check_overlap</code></a></li><li><a href="#SortedIntervals.interval_indices-Tuple{Any, Interval}"><code>SortedIntervals.interval_indices</code></a></li><li><a href="#SortedIntervals.interval_intersect-Tuple{Interval, Interval}"><code>SortedIntervals.interval_intersect</code></a></li><li><a href="#SortedIntervals.interval_intersections-Tuple{AbstractVector{&lt;:Interval}, AbstractVector{&lt;:Interval}}"><code>SortedIntervals.interval_intersections</code></a></li><li><a href="#SortedIntervals.intervals_diff-Tuple{AbstractVector{&lt;:Interval}, Any}"><code>SortedIntervals.intervals_diff</code></a></li><li><a href="#SortedIntervals.is_subinterval-Tuple{Interval, Interval}"><code>SortedIntervals.is_subinterval</code></a></li><li><a href="#SortedIntervals.mask_events-Tuple{Any, Interval}"><code>SortedIntervals.mask_events</code></a></li><li><a href="#SortedIntervals.maximum_interval_overlap-Tuple{AbstractVector{&lt;:Interval}, Interval}"><code>SortedIntervals.maximum_interval_overlap</code></a></li><li><a href="#SortedIntervals.measure-Tuple{Interval}"><code>SortedIntervals.measure</code></a></li><li><a href="#SortedIntervals.midpoint-Tuple{Interval}"><code>SortedIntervals.midpoint</code></a></li><li><a href="#SortedIntervals.relative_interval-Tuple{Interval, Interval}"><code>SortedIntervals.relative_interval</code></a></li></ul><article><details class="docstring" open="true"><summary id="EventIntervals.EventIntervals"><a class="docstring-binding" href="#EventIntervals.EventIntervals"><code>EventIntervals.EventIntervals</code></a> — <span class="docstring-category">Module</span></summary><section><div><pre><code class="language-julia hljs">EventIntervals</code></pre><p>Interval-aware data structures for point processes. Couples timestamped event collections (<a href="../guide/#Points"><code>Points</code></a>) with the temporal domains (<a href="#EventIntervals.Interval"><code>Interval</code></a>) they are defined on, so that slicing, intersecting, downsampling, and transforming operations keep points and their intervals in sync.</p><p>Core types come in &quot;naked&quot; (coordinates only) and &quot;marked&quot; (coordinates + metadata) variants: <a href="#EventIntervals.NakedPoint"><code>NakedPoint</code></a>/<a href="#EventIntervals.MarkedPoint"><code>MarkedPoint</code></a>, <a href="#EventIntervals.NakedInterval"><code>NakedInterval</code></a>/<a href="#EventIntervals.MarkedInterval"><code>MarkedInterval</code></a>, <a href="../guide/#NakedPoints"><code>NakedPoints</code></a>/<a href="../guide/#VariablePoints"><code>VariablePoints</code></a>. <a href="../guide/#SubPoints"><code>SubPoints</code></a> provides lazy, zero-copy views into any points collection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/EventIntervals.jl#L1-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.Interval"><a class="docstring-binding" href="#EventIntervals.Interval"><code>EventIntervals.Interval</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Interval{E,N}</code></pre><p>Abstract supertype for interval types, parameterised by the element type <code>E</code> and dimensionality <code>N</code>. All concrete subtypes must implement <a href="#EventIntervals.bounds-Tuple{NakedInterval}"><code>bounds</code></a> returning an <code>NTuple{2,E}</code>.</p><p>Supports <code>in</code> membership testing, <a href="#SortedIntervals.measure-Tuple{Interval}"><code>measure</code></a>, <a href="#SortedIntervals.midpoint-Tuple{Interval}"><code>midpoint</code></a>, <a href="#EventIntervals.bounds-Tuple{NakedInterval}"><code>bounds</code></a>, and <a href="#EventIntervals.nakedinterval-Tuple{Interval}"><code>nakedinterval</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/intervals.jl#L1-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.IntervalSet"><a class="docstring-binding" href="#EventIntervals.IntervalSet"><code>EventIntervals.IntervalSet</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IntervalSet{E,T} &lt;: Interval{E,1}</code></pre><p>A composite interval formed from a tuple of contiguous, ordered sub-intervals. Behaves as a single interval whose bounds span from the start of the first component to the end of the last.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">IntervalSet(i1::Interval, i2::Interval, ...)
IntervalSet(intervals::AbstractVector{&lt;:Interval})
IntervalSet(intervals::NTuple{N,Interval})</code></pre><p>Throws <code>ArgumentError</code> if the intervals are not contiguous (each must start where the previous one ends) or if the collection is empty.</p><p>See also <a href="#EventIntervals.get_mark-Tuple{MarkedInterval}"><code>get_mark</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/intervals.jl#L214-L231">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.MarkedInterval"><a class="docstring-binding" href="#EventIntervals.MarkedInterval"><code>EventIntervals.MarkedInterval</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MarkedInterval{D&lt;:Number,M} &lt;: Interval{D,1}</code></pre><p>An interval with attached metadata of type <code>M</code>. The mark can be any type.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">MarkedInterval(interval::NakedInterval, mark)
MarkedInterval((a, b), mark)
MarkedInterval(a, b, mark)</code></pre><p>See also <a href="#EventIntervals.get_mark-Tuple{MarkedInterval}"><code>get_mark</code></a>, <a href="#EventIntervals.nakedinterval-Tuple{Interval}"><code>nakedinterval</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/intervals.jl#L138-L150">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.MarkedPoint"><a class="docstring-binding" href="#EventIntervals.MarkedPoint"><code>EventIntervals.MarkedPoint</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MarkedPoint{E,M} &lt;: Point{E}</code></pre><p>A timestamp of type <code>E</code> paired with a mark of type <code>M</code>. Marks can be any type — numbers, symbols, tuples, or custom structs.</p><p>See also <a href="#EventIntervals.push_mark-Tuple{MarkedPoint, Any}"><code>push_mark</code></a>, <a href="#EventIntervals.pop_mark-Tuple{MarkedPoint{&lt;:Any, &lt;:Tuple}}"><code>pop_mark</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/point.jl#L48-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.MarkedPoints"><a class="docstring-binding" href="#EventIntervals.MarkedPoints"><code>EventIntervals.MarkedPoints</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MarkedPoints{E,N,I,M}</code></pre><p>Type alias for <code>Points{E,N,I,MarkedPoint{E,M}}</code> — any <a href="../guide/#Points"><code>Points</code></a> collection whose elements are <a href="#EventIntervals.MarkedPoint"><code>MarkedPoint</code></a> values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/points.jl#L13-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.NakedInterval"><a class="docstring-binding" href="#EventIntervals.NakedInterval"><code>EventIntervals.NakedInterval</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NakedInterval{D&lt;:Number} &lt;: Interval{D,1}</code></pre><p>A plain interval storing <code>(start, stop)</code> bounds with no metadata. The fundamental interval type in EventIntervals.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">NakedInterval((a, b))
NakedInterval(a, b)</code></pre><p>Arguments are promoted to a common numeric type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/intervals.jl#L101-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.NakedPoint"><a class="docstring-binding" href="#EventIntervals.NakedPoint"><code>EventIntervals.NakedPoint</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NakedPoint{E} &lt;: Point{E}</code></pre><p>A bare timestamp with no metadata. Wraps a single value of type <code>E</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/point.jl#L15-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.NakedPoints"><a class="docstring-binding" href="#EventIntervals.NakedPoints"><code>EventIntervals.NakedPoints</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NakedPoints{E,I,A} &lt;: Points{E,1,I,NakedPoint{E}}</code></pre><p>A sorted vector of timestamps of type <code>E</code> defined on an interval of type <code>I</code>. Points need not be strictly increasing, but must be non-decreasingly sorted.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">NakedPoints(points::AbstractVector{E}, interval::Interval{E})
NakedPoints(points::AbstractVector{E}, (a, b))
NakedPoints(points::AbstractVector{E}, a, b)
NakedPoints(points::AbstractVector)</code></pre><p>The first three forms accept an explicit interval; unsorted input is sorted in-place. The last form infers the interval from <code>(minimum(points), maximum(points))</code> and requires a non-empty vector.</p><p>Throws <code>ArgumentError</code> if points fall outside the given interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/points.jl#L91-L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.Point"><a class="docstring-binding" href="#EventIntervals.Point"><code>EventIntervals.Point</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Point{E}</code></pre><p>Abstract supertype for timestamped event types, parameterised by the element type <code>E</code> of the timestamp. Concrete subtypes are <a href="#EventIntervals.NakedPoint"><code>NakedPoint</code></a> and <a href="#EventIntervals.MarkedPoint"><code>MarkedPoint</code></a>.</p><p><code>Point</code> values support <code>isless</code> comparison with <code>Number</code> values, delegating to <a href="#EventIntervals.nakedpointvalue-Tuple{NakedPoint}"><code>nakedpointvalue</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/point.jl#L1-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.Points"><a class="docstring-binding" href="#EventIntervals.Points"><code>EventIntervals.Points</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Points{E,N,I&lt;:Interval{E},T&lt;:Point{E}} &lt;: AbstractVector{T}</code></pre><p>Abstract supertype for read-only collections of <a href="#EventIntervals.Point"><code>Point</code></a> values defined on an <a href="#EventIntervals.Interval"><code>Interval</code></a>. Subtypes are <a href="../guide/#NakedPoints"><code>NakedPoints</code></a>, <a href="../guide/#VariablePoints"><code>VariablePoints</code></a>, and <a href="../guide/#SubPoints"><code>SubPoints</code></a>.</p><p><code>Points</code> implements <code>AbstractVector</code>, so indexing, iteration, and <code>length</code> work as expected. Assignment via <code>setindex!</code> throws <code>ReadOnlyMemoryError</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/points.jl#L1-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.RelativeInterval"><a class="docstring-binding" href="#EventIntervals.RelativeInterval"><code>EventIntervals.RelativeInterval</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RelativeInterval{D,I,J} &lt;: Interval{D,1}</code></pre><p>An interval expressed in coordinates relative to a reference interval. Useful for defining peri-event windows (e.g. &quot;100 ms before to 300 ms after stimulus onset&quot;).</p><pre><code class="language-julia hljs">RelativeInterval(reference::Interval, anchored_left::Bool, offset::Interval)</code></pre><p>If <code>anchored_left</code> is <code>true</code>, offsets are relative to the start of <code>reference</code>; if <code>false</code>, relative to the end.</p><p><a href="#EventIntervals.bounds-Tuple{NakedInterval}"><code>bounds</code></a> resolves to absolute coordinates by adding the anchor point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/intervals.jl#L178-L190">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.SubPoints"><a class="docstring-binding" href="#EventIntervals.SubPoints"><code>EventIntervals.SubPoints</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SubPoints{E,M,I,P} &lt;: Points{E,1,I,M}</code></pre><p>A lazy, zero-copy view of a <a href="../guide/#Points"><code>Points</code></a> collection restricted to a sub-interval. Indexing uses a precomputed offset for O(1) element access.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SubPoints(points::Points, interval::Interval)
SubPoints(points::Points, (a, b))
SubPoints(points::Points, a, b)</code></pre><p>The sub-interval must be contained within <code>interval(points)</code> (throws <code>ArgumentError</code> otherwise). Nesting <code>SubPoints</code> inside another <code>SubPoints</code> flattens automatically, referencing the original underlying data.</p><p>See also <a href="#EventIntervals.maybe_subpoints-Tuple{Points, Interval}"><code>maybe_subpoints</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/points.jl#L333-L350">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.VariablePoints"><a class="docstring-binding" href="#EventIntervals.VariablePoints"><code>EventIntervals.VariablePoints</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VariablePoints{E,I,P,M,A} &lt;: Points{E,1,I,MarkedPoint{E,M}}</code></pre><p>A sorted collection of timestamps paired with per-point marks of type <code>M</code>. Wraps a <a href="../guide/#NakedPoints"><code>NakedPoints</code></a> for the timestamps and a separate marks vector.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">VariablePoints(nakedpoints::NakedPoints, marks::AbstractVector)
VariablePoints(points::AbstractVector, marks::AbstractVector, interval_args...)
VariablePoints(pts::AbstractVector{&lt;:MarkedPoint}, interval_args...)</code></pre><p>The second form sorts <code>points</code> and permutes <code>marks</code> to match. The third form destructures <code>MarkedPoint</code> elements. All forms require <code>length(points) == length(marks)</code>.</p><p>See also <a href="#EventIntervals.get_mark-Tuple{MarkedInterval}"><code>get_mark</code></a>, <a href="#EventIntervals.point_values-Tuple{AbstractVector{&lt;:NakedPoint}}"><code>point_values</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/points.jl#L236-L252">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.bounds-Tuple{NakedInterval}"><a class="docstring-binding" href="#EventIntervals.bounds-Tuple{NakedInterval}"><code>EventIntervals.bounds</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bounds(m::Interval) -&gt; NTuple{2,E}
bounds(p::Points) -&gt; NTuple{2,E}</code></pre><p>Return the <code>(start, stop)</code> bounds of an interval or points collection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/intervals.jl#L119-L124">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.chunk-Union{Tuple{E}, Tuple{Interval{E, 1}, E}, Tuple{Interval{E, 1}, E, Bool}} where E"><a class="docstring-binding" href="#EventIntervals.chunk-Union{Tuple{E}, Tuple{Interval{E, 1}, E}, Tuple{Interval{E, 1}, E, Bool}} where E"><code>EventIntervals.chunk</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">chunk(int::Interval{E,1}, chunk_len::E, exact::Bool=false) where E -&gt; Vector{NakedInterval{E}}</code></pre><p>Break <code>int</code> into consecutive sub-intervals of length <code>chunk_len</code>. If <code>exact</code> is <code>true</code>, any trailing remainder shorter than <code>chunk_len</code> is dropped; otherwise it is included as the final chunk.</p><p><code>chunk_len</code> must be positive (throws <code>ArgumentError</code> otherwise).</p><pre><code class="language-julia hljs">chunk(intervals::AbstractVector{&lt;:Interval{E,1}}, chunk_len::E, exact::Bool=true) where E</code></pre><p>Apply chunking to each interval in the vector and concatenate the results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/intervals.jl#L399-L411">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.complement-Union{Tuple{E}, Tuple{Interval{E}, Interval}} where E"><a class="docstring-binding" href="#EventIntervals.complement-Union{Tuple{E}, Tuple{Interval{E}, Interval}} where E"><code>EventIntervals.complement</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">complement(dom::Interval, int::Interval) -&gt; Vector{NakedInterval}
complement(dom::Interval, ints::AbstractVector{&lt;:Interval}) -&gt; Vector{NakedInterval}</code></pre><p>Return the portions of <code>dom</code> not covered by <code>int</code> (or by any interval in <code>ints</code>). The vector form requires <code>ints</code> to be sorted by start time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/intervals.jl#L313-L319">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.get_mark-Tuple{MarkedInterval}"><a class="docstring-binding" href="#EventIntervals.get_mark-Tuple{MarkedInterval}"><code>EventIntervals.get_mark</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_mark(m::MarkedInterval)
get_mark(iset::IntervalSet)
get_mark(vp::VariablePoints)
get_mark(sp::SubPoints)</code></pre><p>Retrieve the mark from a marked object. For an <a href="#EventIntervals.IntervalSet"><code>IntervalSet</code></a>, returns the mark of the first <a href="#EventIntervals.MarkedInterval"><code>MarkedInterval</code></a> component. For <a href="../guide/#VariablePoints"><code>VariablePoints</code></a> or marked <a href="../guide/#SubPoints"><code>SubPoints</code></a>, returns the marks vector.</p><p>Throws an error if no mark is found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/intervals.jl#L162-L173">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.interval-Tuple{Points}"><a class="docstring-binding" href="#EventIntervals.interval-Tuple{Points}"><code>EventIntervals.interval</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interval(p::Points) -&gt; Interval</code></pre><p>Return the domain interval on which the points collection is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/points.jl#L45-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.interval_intersections_subpoints-Union{Tuple{P}, Tuple{M}, Tuple{E}, Tuple{AbstractVector{P}, AbstractVector{&lt;:Interval{E}}}} where {E, M, P&lt;:(Points{E, 1, &lt;:Any, M})}"><a class="docstring-binding" href="#EventIntervals.interval_intersections_subpoints-Union{Tuple{P}, Tuple{M}, Tuple{E}, Tuple{AbstractVector{P}, AbstractVector{&lt;:Interval{E}}}} where {E, M, P&lt;:(Points{E, 1, &lt;:Any, M})}"><code>EventIntervals.interval_intersections_subpoints</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interval_intersections_subpoints(points::AbstractVector{&lt;:Points}, intervals::AbstractVector{&lt;:Interval}) -&gt; Vector{SubPoints}</code></pre><p>For each overlap between a points collection in <code>points</code> and an interval in <code>intervals</code>, produce a <a href="../guide/#SubPoints"><code>SubPoints</code></a> view. Both inputs must be sorted by start time.</p><p>This is the lower-level function behind <a href="#EventIntervals.points_intersects-Tuple{AbstractVector{&lt;:Points}, AbstractVector{&lt;:Points}}"><code>points_intersects</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/points.jl#L462-L469">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.interval_levels-Union{Tuple{AbstractVector{&lt;:Interval{E, 1}}}, Tuple{E}} where E"><a class="docstring-binding" href="#EventIntervals.interval_levels-Union{Tuple{AbstractVector{&lt;:Interval{E, 1}}}, Tuple{E}} where E"><code>EventIntervals.interval_levels</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interval_levels(intervals::AbstractVector{&lt;:Interval{E,1}}) where E -&gt; Vector{MarkedInterval{E,Int}}</code></pre><p>Partition the time axis into segments labelled by the depth of interval overlap. Returns a vector of <a href="#EventIntervals.MarkedInterval"><code>MarkedInterval</code></a> where each mark is the number of input intervals overlapping that segment.</p><p><code>intervals</code> must be sorted by start time and non-empty (throws <code>ArgumentError</code> otherwise).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/intervals.jl#L367-L375">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.join_points-Union{Tuple{Points{&lt;:Any, &lt;:Any, &lt;:Any, P}}, Tuple{P}} where P&lt;:NakedPoint"><a class="docstring-binding" href="#EventIntervals.join_points-Union{Tuple{Points{&lt;:Any, &lt;:Any, &lt;:Any, P}}, Tuple{P}} where P&lt;:NakedPoint"><code>EventIntervals.join_points</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">join_points(pt::Points) -&gt; NakedPoints or VariablePoints
join_points(pt1::Points, pt2::Points, pts::Points...) -&gt; NakedPoints or VariablePoints</code></pre><p>Materialise or merge point collections. The single-argument form copies a (possibly lazy) <code>Points</code> into a concrete <code>NakedPoints</code> or <code>VariablePoints</code>. The multi-argument form concatenates points and sorts the result; the output interval is the union of all input intervals. All arguments must have the same point type (all naked or all marked).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/points.jl#L607-L615">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.maybe_subpoints-Tuple{Points, Interval}"><a class="docstring-binding" href="#EventIntervals.maybe_subpoints-Tuple{Points, Interval}"><code>EventIntervals.maybe_subpoints</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">maybe_subpoints(points::Points, i::Interval) -&gt; SubPoints or nothing</code></pre><p>Return a <a href="../guide/#SubPoints"><code>SubPoints</code></a> view if <code>i</code> overlaps with the domain of <code>points</code>, or <code>nothing</code> if there is no intersection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/points.jl#L400-L405">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.nakedinterval-Tuple{Interval}"><a class="docstring-binding" href="#EventIntervals.nakedinterval-Tuple{Interval}"><code>EventIntervals.nakedinterval</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nakedinterval(i::Interval) -&gt; NakedInterval
nakedinterval(p::Points) -&gt; NakedInterval</code></pre><p>Strip any mark or wrapper to obtain a plain <a href="#EventIntervals.NakedInterval"><code>NakedInterval</code></a>. Identity on <code>NakedInterval</code> inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/intervals.jl#L81-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.nakedpoints-Tuple{NakedPoints}"><a class="docstring-binding" href="#EventIntervals.nakedpoints-Tuple{NakedPoints}"><code>EventIntervals.nakedpoints</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nakedpoints(p::Points) -&gt; NakedPoints</code></pre><p>Extract or return the underlying <a href="../guide/#NakedPoints"><code>NakedPoints</code></a> (timestamps only, no marks). Identity on <code>NakedPoints</code> inputs. For <a href="../guide/#SubPoints"><code>SubPoints</code></a>, materialises a new <code>NakedPoints</code> covering the sub-interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/points.jl#L213-L219">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.nakedpointvalue-Tuple{NakedPoint}"><a class="docstring-binding" href="#EventIntervals.nakedpointvalue-Tuple{NakedPoint}"><code>EventIntervals.nakedpointvalue</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nakedpointvalue(pt::Point) -&gt; E</code></pre><p>Return the raw timestamp value from a <a href="#EventIntervals.Point"><code>Point</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/point.jl#L29-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.nakedvalues-Tuple{Points, Any, Any}"><a class="docstring-binding" href="#EventIntervals.nakedvalues-Tuple{Points, Any, Any}"><code>EventIntervals.nakedvalues</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nakedvalues(p::Points) -&gt; AbstractVector
nakedvalues(p::Points, b, e) -&gt; AbstractVector</code></pre><p>Return the raw timestamp values from a points collection, stripping any marks. Equivalent to <code>point_values(nakedpoints(p), ...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/points.jl#L81-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.point_values-Tuple{AbstractVector{&lt;:NakedPoint}}"><a class="docstring-binding" href="#EventIntervals.point_values-Tuple{AbstractVector{&lt;:NakedPoint}}"><code>EventIntervals.point_values</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">point_values(pts)</code></pre><p>Extract the underlying value arrays from a collection of points.</p><p>For a vector of <a href="#EventIntervals.NakedPoint"><code>NakedPoint</code></a>, returns a vector of timestamps. For a vector of <a href="#EventIntervals.MarkedPoint"><code>MarkedPoint</code></a>, returns <code>(timestamps, marks)</code>. For <a href="../guide/#Points"><code>Points</code></a> subtypes, see <a href="../guide/#NakedPoints"><code>NakedPoints</code></a>, <a href="../guide/#VariablePoints"><code>VariablePoints</code></a>, and <a href="../guide/#SubPoints"><code>SubPoints</code></a> for range-query forms <code>point_values(pts, b, e)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/point.jl#L36-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.points-Union{Tuple{M}, Tuple{Points{&lt;:Any, &lt;:Any, &lt;:Any, M}, Vararg{Any}}} where M"><a class="docstring-binding" href="#EventIntervals.points-Union{Tuple{M}, Tuple{Points{&lt;:Any, &lt;:Any, &lt;:Any, M}, Vararg{Any}}} where M"><code>EventIntervals.points</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">points(p::Points, [b, e]) -&gt; Vector{&lt;:Point}</code></pre><p>Materialise the <a href="#EventIntervals.Point"><code>Point</code></a> objects from a points collection. The optional range <code>[b, e]</code> restricts to points within those bounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/points.jl#L71-L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.points_intersects-Tuple{AbstractVector{&lt;:Points}, AbstractVector{&lt;:Points}}"><a class="docstring-binding" href="#EventIntervals.points_intersects-Tuple{AbstractVector{&lt;:Points}, AbstractVector{&lt;:Points}}"><code>EventIntervals.points_intersects</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">points_intersects(pts1::AbstractVector{&lt;:Points}, pts2::AbstractVector{&lt;:Points}) -&gt; (Vector{SubPoints}, Vector{SubPoints})</code></pre><p>Restrict two vectors of <a href="../guide/#Points"><code>Points</code></a> to only the time ranges where both have coverage. Returns a pair of <code>SubPoints</code> vectors aligned to the same intersection intervals. Both inputs must be sorted by start time.</p><p>See also <a href="#EventIntervals.interval_intersections_subpoints-Union{Tuple{P}, Tuple{M}, Tuple{E}, Tuple{AbstractVector{P}, AbstractVector{&lt;:Interval{E}}}} where {E, M, P&lt;:(Points{E, 1, &lt;:Any, M})}"><code>interval_intersections_subpoints</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/points.jl#L494-L502">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.pop_mark-Tuple{MarkedPoint{&lt;:Any, &lt;:Tuple}}"><a class="docstring-binding" href="#EventIntervals.pop_mark-Tuple{MarkedPoint{&lt;:Any, &lt;:Tuple}}"><code>EventIntervals.pop_mark</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pop_mark(mp::MarkedPoint{&lt;:Any,&lt;:Tuple}) -&gt; (MarkedPoint, mark)</code></pre><p>Remove the outermost mark from a tuple-marked <a href="#EventIntervals.MarkedPoint"><code>MarkedPoint</code></a>, returning the modified point and the removed mark. If the mark tuple is empty, returns <code>(mp, nothing)</code>.</p><p>See also <a href="#EventIntervals.push_mark-Tuple{MarkedPoint, Any}"><code>push_mark</code></a>, <a href="#EventIntervals.pop_marks-Tuple{VariablePoints}"><code>pop_marks</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/point.jl#L92-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.pop_marks-Tuple{VariablePoints}"><a class="docstring-binding" href="#EventIntervals.pop_marks-Tuple{VariablePoints}"><code>EventIntervals.pop_marks</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pop_marks(p::VariablePoints) -&gt; VariablePoints</code></pre><p>Strip the outermost element from tuple marks on all points. Each mark <code>(a, b)</code> becomes <code>b</code>. This is the collection-level counterpart of <a href="#EventIntervals.pop_mark-Tuple{MarkedPoint{&lt;:Any, &lt;:Tuple}}"><code>pop_mark</code></a> and is useful for removing the merge-count mark added by <a href="#EventIntervals.pp_downsamp-Union{Tuple{RetType}, Tuple{M}, Tuple{E}, Tuple{Points{E, 1, &lt;:Any, M}, Any, Any, Any}, Tuple{Points{E, 1, &lt;:Any, M}, Any, Any, Any, Function}, Tuple{Points{E, 1, &lt;:Any, M}, Any, Any, Any, Function, Type{RetType}}} where {E, M, RetType}"><code>pp_downsamp</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/points.jl#L594-L600">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.pp_downsamp-Union{Tuple{RetType}, Tuple{M}, Tuple{E}, Tuple{Points{E, 1, &lt;:Any, M}, Any, Any, Any}, Tuple{Points{E, 1, &lt;:Any, M}, Any, Any, Any, Function}, Tuple{Points{E, 1, &lt;:Any, M}, Any, Any, Any, Function, Type{RetType}}} where {E, M, RetType}"><a class="docstring-binding" href="#EventIntervals.pp_downsamp-Union{Tuple{RetType}, Tuple{M}, Tuple{E}, Tuple{Points{E, 1, &lt;:Any, M}, Any, Any, Any}, Tuple{Points{E, 1, &lt;:Any, M}, Any, Any, Any, Function}, Tuple{Points{E, 1, &lt;:Any, M}, Any, Any, Any, Function, Type{RetType}}} where {E, M, RetType}"><code>EventIntervals.pp_downsamp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pp_downsamp(p::Points, b, e, resolution, [merge_func=pt_merge], [RetType=eltype(p)]) -&gt; VariablePoints</code></pre><p>Downsample points within <code>[b, e]</code> by merging consecutive points closer than <code>resolution</code>. Adjacent points whose gap is less than <code>resolution</code> are merged using <code>merge_func</code>. Each merged point receives a count mark (via <a href="#EventIntervals.push_mark-Tuple{MarkedPoint, Any}"><code>push_mark</code></a>) recording how many original points were combined.</p><p>The default <code>merge_func</code> is <a href="#EventIntervals.pt_merge-Tuple{AbstractVector{&lt;:NakedPoint{&lt;:Number}}}"><code>pt_merge</code></a> (mean of timestamps and marks). <code>RetType</code> specifies the return type of <code>merge_func</code> for type stability.</p><p>See also <a href="#EventIntervals.pt_merge-Tuple{AbstractVector{&lt;:NakedPoint{&lt;:Number}}}"><code>pt_merge</code></a>, <a href="#EventIntervals.pt_extent_merge-Tuple{AbstractVector{&lt;:MarkedPoint{&lt;:Number, &lt;:Number}}}"><code>pt_extent_merge</code></a>, <a href="#EventIntervals.pop_marks-Tuple{VariablePoints}"><code>pop_marks</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/points.jl#L512-L524">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.pt_extent_merge-Tuple{AbstractVector{&lt;:MarkedPoint{&lt;:Number, &lt;:Number}}}"><a class="docstring-binding" href="#EventIntervals.pt_extent_merge-Tuple{AbstractVector{&lt;:MarkedPoint{&lt;:Number, &lt;:Number}}}"><code>EventIntervals.pt_extent_merge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pt_extent_merge(pts::AbstractVector{&lt;:MarkedPoint}) -&gt; MarkedPoint
pt_extent_merge(pts::AbstractVector{&lt;:NakedPoint}) -&gt; MarkedPoint</code></pre><p>Merge a group of points by averaging timestamps and recording the extent <code>(min, max)</code>. For <a href="#EventIntervals.MarkedPoint"><code>MarkedPoint</code></a> inputs, returns <code>MarkedPoint(mean_time, ((min_time, max_time), mean_mark))</code>. For <a href="#EventIntervals.NakedPoint"><code>NakedPoint</code></a> inputs, returns <code>MarkedPoint(mean_time, (min_time, max_time))</code>.</p><p>Alternative merge function for <a href="#EventIntervals.pp_downsamp-Union{Tuple{RetType}, Tuple{M}, Tuple{E}, Tuple{Points{E, 1, &lt;:Any, M}, Any, Any, Any}, Tuple{Points{E, 1, &lt;:Any, M}, Any, Any, Any, Function}, Tuple{Points{E, 1, &lt;:Any, M}, Any, Any, Any, Function, Type{RetType}}} where {E, M, RetType}"><code>pp_downsamp</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/points.jl#L569-L578">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.pt_merge-Tuple{AbstractVector{&lt;:NakedPoint{&lt;:Number}}}"><a class="docstring-binding" href="#EventIntervals.pt_merge-Tuple{AbstractVector{&lt;:NakedPoint{&lt;:Number}}}"><code>EventIntervals.pt_merge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pt_merge(pts::AbstractVector{&lt;:NakedPoint}) -&gt; NakedPoint
pt_merge(pts::AbstractVector{&lt;:MarkedPoint}) -&gt; MarkedPoint</code></pre><p>Merge a group of points by averaging their timestamps (and marks, for <a href="#EventIntervals.MarkedPoint"><code>MarkedPoint</code></a>). Used as the default merge function in <a href="#EventIntervals.pp_downsamp-Union{Tuple{RetType}, Tuple{M}, Tuple{E}, Tuple{Points{E, 1, &lt;:Any, M}, Any, Any, Any}, Tuple{Points{E, 1, &lt;:Any, M}, Any, Any, Any, Function}, Tuple{Points{E, 1, &lt;:Any, M}, Any, Any, Any, Function, Type{RetType}}} where {E, M, RetType}"><code>pp_downsamp</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/points.jl#L554-L560">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.push_mark-Tuple{MarkedPoint, Any}"><a class="docstring-binding" href="#EventIntervals.push_mark-Tuple{MarkedPoint, Any}"><code>EventIntervals.push_mark</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">push_mark(p::NakedPoint, mark) -&gt; MarkedPoint
push_mark(mp::MarkedPoint, newmark) -&gt; MarkedPoint</code></pre><p>Add a mark to a point. On a <a href="#EventIntervals.NakedPoint"><code>NakedPoint</code></a>, creates a <a href="#EventIntervals.MarkedPoint"><code>MarkedPoint</code></a>. On a <a href="#EventIntervals.MarkedPoint"><code>MarkedPoint</code></a>, nests the new mark into a tuple <code>(newmark, existing_mark)</code>, forming a mark stack.</p><p>See also <a href="#EventIntervals.pop_mark-Tuple{MarkedPoint{&lt;:Any, &lt;:Tuple}}"><code>pop_mark</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/point.jl#L79-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.rate-Tuple{Points}"><a class="docstring-binding" href="#EventIntervals.rate-Tuple{Points}"><code>EventIntervals.rate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rate(p::Points) -&gt; Number
rate(p::Points, b, e) -&gt; Number
rate(ps::AbstractVector{&lt;:Points}) -&gt; Number or nothing</code></pre><p>Compute the event rate (count / duration). The two-argument form restricts the calculation to the range <code>[b, e]</code>. The vector form computes the aggregate rate across all collections, returning <code>nothing</code> if the vector is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/points.jl#L24-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.shift_interval-Tuple{NakedInterval, Number}"><a class="docstring-binding" href="#EventIntervals.shift_interval-Tuple{NakedInterval, Number}"><code>EventIntervals.shift_interval</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">shift_interval(a::Interval, offset::Number) -&gt; Interval
shift_interval(offset::Number) -&gt; Function</code></pre><p>Translate an interval by adding <code>offset</code> to both bounds. Preserves the mark on a <a href="#EventIntervals.MarkedInterval"><code>MarkedInterval</code></a>. The single-argument form returns a curried function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/intervals.jl#L543-L549">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.shrink-Tuple{Interval, Any}"><a class="docstring-binding" href="#EventIntervals.shrink-Tuple{Interval, Any}"><code>EventIntervals.shrink</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">shrink(int::Interval, shrink_measure) -&gt; Interval
shrink(ints::AbstractVector{&lt;:Interval}, shrink_measure) -&gt; Vector</code></pre><p>Contract an interval inward by <code>shrink_measure / 2</code> from each end. If <code>shrink_measure</code> exceeds the interval&#39;s measure, the result is a zero-width interval at the midpoint.</p><p>The vector form drops any intervals whose measure is less than <code>shrink_measure</code> before shrinking the survivors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/intervals.jl#L460-L469">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.subinterval-Tuple{Interval, Real, Real}"><a class="docstring-binding" href="#EventIntervals.subinterval-Tuple{Interval, Real, Real}"><code>EventIntervals.subinterval</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">subinterval(int::Interval{E,1}, b::Real, e::Real) -&gt; Interval
subinterval(int::Interval{E,1}, sub::NakedInterval{E}) -&gt; Interval</code></pre><p>Return the portion of <code>int</code> delimited by <code>[b, e]</code>. Preserves the type and mark of <code>int</code> (e.g. a <a href="#EventIntervals.MarkedInterval"><code>MarkedInterval</code></a> yields a <code>MarkedInterval</code> with the same mark).</p><p>Throws <code>ArgumentError</code> if <code>[b, e]</code> is not contained within <code>int</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/intervals.jl#L39-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EventIntervals.translate-Tuple{NakedPoints, Any}"><a class="docstring-binding" href="#EventIntervals.translate-Tuple{NakedPoints, Any}"><code>EventIntervals.translate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">translate(p::NakedPoints, offset) -&gt; NakedPoints
translate(p::VariablePoints, offset) -&gt; VariablePoints</code></pre><p>Shift all timestamps and the domain interval by <code>offset</code>. Marks are preserved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/points.jl#L222-L227">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.duration-Tuple{Points}"><a class="docstring-binding" href="#SignalIndices.duration-Tuple{Points}"><code>SignalIndices.duration</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">duration(p::Points) -&gt; Number</code></pre><p>Return the duration (measure) of the domain interval. Equivalent to <code>measure(interval(p))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/points.jl#L54-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SignalIndices.time_interval-Tuple{Points}"><a class="docstring-binding" href="#SignalIndices.time_interval-Tuple{Points}"><code>SignalIndices.time_interval</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">time_interval(p::Points) -&gt; Interval</code></pre><p>Return the domain interval. Synonym for <a href="#EventIntervals.interval-Tuple{Points}"><code>interval</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/points.jl#L62-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SortedIntervals.check_overlap-Tuple{Interval, Interval}"><a class="docstring-binding" href="#SortedIntervals.check_overlap-Tuple{Interval, Interval}"><code>SortedIntervals.check_overlap</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check_overlap(m::Interval, n::Interval) -&gt; Bool</code></pre><p>Return <code>true</code> if intervals <code>m</code> and <code>n</code> overlap (share at least one point).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/intervals.jl#L74-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SortedIntervals.interval_indices-Tuple{Any, Interval}"><a class="docstring-binding" href="#SortedIntervals.interval_indices-Tuple{Any, Interval}"><code>SortedIntervals.interval_indices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interval_indices(basis, i::Interval)
interval_indices(basis, a::AbstractVector{&lt;:Interval})</code></pre><p>Return the indices into <code>basis</code> that fall within interval <code>i</code>. The vector form maps over each interval independently.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/intervals.jl#L501-L507">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SortedIntervals.interval_intersect-Tuple{Interval, Interval}"><a class="docstring-binding" href="#SortedIntervals.interval_intersect-Tuple{Interval, Interval}"><code>SortedIntervals.interval_intersect</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interval_intersect(a::Interval, b::Interval) -&gt; NakedInterval or nothing</code></pre><p>Return the intersection of two intervals as a <a href="#EventIntervals.NakedInterval"><code>NakedInterval</code></a>, or <code>nothing</code> if they do not overlap.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/intervals.jl#L50-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SortedIntervals.interval_intersections-Tuple{AbstractVector{&lt;:Interval}, AbstractVector{&lt;:Interval}}"><a class="docstring-binding" href="#SortedIntervals.interval_intersections-Tuple{AbstractVector{&lt;:Interval}, AbstractVector{&lt;:Interval}}"><code>SortedIntervals.interval_intersections</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interval_intersections(a::AbstractVector{&lt;:Interval}, b::AbstractVector{&lt;:Interval}) -&gt; Vector{NakedInterval}</code></pre><p>Compute all pairwise intersections between two sorted vectors of intervals. Both <code>a</code> and <code>b</code> must be sorted by start time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/intervals.jl#L61-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SortedIntervals.intervals_diff-Tuple{AbstractVector{&lt;:Interval}, Any}"><a class="docstring-binding" href="#SortedIntervals.intervals_diff-Tuple{AbstractVector{&lt;:Interval}, Any}"><code>SortedIntervals.intervals_diff</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">intervals_diff(a::AbstractVector{&lt;:Interval}, b) -&gt; Vector{NakedInterval}
intervals_diff(a, b::AbstractVector{&lt;:Interval}) -&gt; Vector{NakedInterval}</code></pre><p>Compute the set difference of two sorted interval vectors: the portions of <code>a</code> not covered by <code>b</code>. Accepts <a href="#EventIntervals.Interval"><code>Interval</code></a> objects or <code>NTuple{2}</code> bounds in either argument position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/intervals.jl#L517-L524">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SortedIntervals.is_subinterval-Tuple{Interval, Interval}"><a class="docstring-binding" href="#SortedIntervals.is_subinterval-Tuple{Interval, Interval}"><code>SortedIntervals.is_subinterval</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_subinterval(m::Interval, parent::Interval) -&gt; Bool</code></pre><p>Return <code>true</code> if <code>m</code> is entirely contained within <code>parent</code> (inclusive bounds).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/intervals.jl#L90-L94">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SortedIntervals.mask_events-Tuple{Any, Interval}"><a class="docstring-binding" href="#SortedIntervals.mask_events-Tuple{Any, Interval}"><code>SortedIntervals.mask_events</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mask_events(evts, i::Interval)</code></pre><p>Filter a sorted event vector to only those falling within interval <code>i</code>. Delegates to <code>SortedIntervals.mask_events(evts, b, e)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/intervals.jl#L490-L495">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SortedIntervals.maximum_interval_overlap-Tuple{AbstractVector{&lt;:Interval}, Interval}"><a class="docstring-binding" href="#SortedIntervals.maximum_interval_overlap-Tuple{AbstractVector{&lt;:Interval}, Interval}"><code>SortedIntervals.maximum_interval_overlap</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">maximum_interval_overlap(xs::AbstractVector{&lt;:Interval}, y::Interval) -&gt; Number</code></pre><p>Return the maximum overlap (in measure) between any single interval in <code>xs</code> and the interval <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/intervals.jl#L533-L538">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SortedIntervals.measure-Tuple{Interval}"><a class="docstring-binding" href="#SortedIntervals.measure-Tuple{Interval}"><code>SortedIntervals.measure</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">measure(m::Interval)
measure(m::IntervalSet)
measure(p::Points)</code></pre><p>Return the length (duration) of an interval. For an <a href="#EventIntervals.IntervalSet"><code>IntervalSet</code></a>, returns the sum of the component measures. For a <a href="../guide/#Points"><code>Points</code></a> collection, returns the measure of its underlying interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/intervals.jl#L28-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SortedIntervals.midpoint-Tuple{Interval}"><a class="docstring-binding" href="#SortedIntervals.midpoint-Tuple{Interval}"><code>SortedIntervals.midpoint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">midpoint(m::Interval)</code></pre><p>Return the midpoint of the interval <code>(b + e) / 2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/intervals.jl#L18-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SortedIntervals.relative_interval-Tuple{Interval, Interval}"><a class="docstring-binding" href="#SortedIntervals.relative_interval-Tuple{Interval, Interval}"><code>SortedIntervals.relative_interval</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">relative_interval(interval, reference) -&gt; NakedInterval</code></pre><p>Express <code>interval</code> in coordinates relative to <code>reference</code> by subtracting the reference start from both bounds. Either argument may be an <a href="#EventIntervals.Interval"><code>Interval</code></a> or an <code>NTuple{2,&lt;:Number}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/galenlynch/EventIntervals.jl/blob/bff63d5e85b6d3f76933487c1b7cae47129316ae/src/intervals.jl#L443-L449">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../guide/">« Usage Guide</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 3 February 2026 01:41">Tuesday 3 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage Guide · EventIntervals.jl</title><meta name="title" content="Usage Guide · EventIntervals.jl"/><meta property="og:title" content="Usage Guide · EventIntervals.jl"/><meta property="twitter:title" content="Usage Guide · EventIntervals.jl"/><meta name="description" content="Documentation for EventIntervals.jl."/><meta property="og:description" content="Documentation for EventIntervals.jl."/><meta property="twitter:description" content="Documentation for EventIntervals.jl."/><meta property="og:url" content="https://galenlynch.github.io/EventIntervals.jl/guide/"/><meta property="twitter:url" content="https://galenlynch.github.io/EventIntervals.jl/guide/"/><link rel="canonical" href="https://galenlynch.github.io/EventIntervals.jl/guide/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">EventIntervals.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Usage Guide</a><ul class="internal"><li><a class="tocitem" href="#Intervals"><span>Intervals</span></a></li><li><a class="tocitem" href="#Points"><span>Points</span></a></li></ul></li><li><a class="tocitem" href="../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Usage Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Usage Guide</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/galenlynch/EventIntervals.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/galenlynch/EventIntervals.jl/blob/main/docs/src/guide.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="guide"><a class="docs-heading-anchor" href="#guide">Usage Guide</a><a id="guide-1"></a><a class="docs-heading-anchor-permalink" href="#guide" title="Permalink"></a></h1><h2 id="Intervals"><a class="docs-heading-anchor" href="#Intervals">Intervals</a><a id="Intervals-1"></a><a class="docs-heading-anchor-permalink" href="#Intervals" title="Permalink"></a></h2><p>Intervals represent bounded temporal domains. The simplest form is a <a href="../api/#EventIntervals.NakedInterval"><code>NakedInterval</code></a>, which wraps a <code>(start, stop)</code> tuple:</p><pre><code class="language-julia hljs">int = NakedInterval((0.0, 10.0))
bounds(int)    # (0.0, 10.0)
measure(int)   # 10.0
midpoint(int)  # 5.0</code></pre><p>You can also construct one from two arguments:</p><pre><code class="language-julia hljs">NakedInterval(0.0, 10.0)</code></pre><h3 id="Marked-Intervals"><a class="docs-heading-anchor" href="#Marked-Intervals">Marked Intervals</a><a id="Marked-Intervals-1"></a><a class="docs-heading-anchor-permalink" href="#Marked-Intervals" title="Permalink"></a></h3><p><a href="../api/#EventIntervals.MarkedInterval"><code>MarkedInterval</code></a> attaches arbitrary metadata to an interval:</p><pre><code class="language-julia hljs">trial = MarkedInterval((0.0, 5.0), &quot;stimulus_A&quot;)
get_mark(trial)   # &quot;stimulus_A&quot;
bounds(trial)      # (0.0, 5.0)
measure(trial)     # 5.0</code></pre><p>Marks can be any type — strings, numbers, symbols, or custom structs.</p><h3 id="Relative-Intervals"><a class="docs-heading-anchor" href="#Relative-Intervals">Relative Intervals</a><a id="Relative-Intervals-1"></a><a class="docs-heading-anchor-permalink" href="#Relative-Intervals" title="Permalink"></a></h3><p><a href="../api/#EventIntervals.RelativeInterval"><code>RelativeInterval</code></a> expresses an interval in coordinates relative to a reference interval. This is useful for defining peri-event windows (e.g., &quot;100 ms before to 300 ms after stimulus onset&quot;):</p><pre><code class="language-julia hljs">reference = NakedInterval((5.0, 8.0))
rel = RelativeInterval(reference, true, NakedInterval((-1.0, 3.0)))
bounds(rel)  # (4.0, 8.0) — anchored to the left edge of reference</code></pre><p>The <code>anchored_left</code> flag controls whether offsets are relative to the start or end of the reference.</p><h3 id="Interval-Sets"><a class="docs-heading-anchor" href="#Interval-Sets">Interval Sets</a><a id="Interval-Sets-1"></a><a class="docs-heading-anchor-permalink" href="#Interval-Sets" title="Permalink"></a></h3><p><a href="../api/#EventIntervals.IntervalSet"><code>IntervalSet</code></a> groups contiguous intervals into a single object. The intervals must touch (no gaps) and be ordered:</p><pre><code class="language-julia hljs">iset = IntervalSet(NakedInterval((0.0, 5.0)), MarkedInterval((5.0, 10.0), :stim))
bounds(iset)    # (0.0, 10.0)
measure(iset)   # 10.0
get_mark(iset)  # :stim — returns the mark of the first marked interval</code></pre><h3 id="Interval-Operations"><a class="docs-heading-anchor" href="#Interval-Operations">Interval Operations</a><a id="Interval-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Interval-Operations" title="Permalink"></a></h3><p><strong>Complement</strong> — find the portions of a domain not covered by an interval or set of intervals:</p><pre><code class="language-julia hljs">domain = NakedInterval((0.0, 10.0))
stim = NakedInterval((3.0, 7.0))
baseline = complement(domain, stim)
# [NakedInterval((0.0, 3.0)), NakedInterval((7.0, 10.0))]</code></pre><p><code>complement</code> also accepts a vector of intervals:</p><pre><code class="language-julia hljs">stims = [NakedInterval((2.0, 4.0)), NakedInterval((6.0, 8.0))]
gaps = complement(domain, stims)
# [NakedInterval((0.0, 2.0)), NakedInterval((4.0, 6.0)), NakedInterval((8.0, 10.0))]</code></pre><p><strong>Chunking</strong> — break an interval into fixed-size pieces:</p><pre><code class="language-julia hljs">chunks = chunk(NakedInterval((0.0, 10.0)), 3.0)
# [NakedInterval((0.0, 3.0)), NakedInterval((3.0, 6.0)),
#  NakedInterval((6.0, 9.0)), NakedInterval((9.0, 10.0))]</code></pre><p>Pass <code>exact=true</code> to drop any remainder that is shorter than <code>chunk_len</code>:</p><pre><code class="language-julia hljs">chunks = chunk(NakedInterval((0.0, 10.0)), 3.0, true)
# [NakedInterval((0.0, 3.0)), NakedInterval((3.0, 6.0)), NakedInterval((6.0, 9.0))]</code></pre><p>Chunking also works on a vector of intervals, concatenating the results:</p><pre><code class="language-julia hljs">chunk([NakedInterval((0.0, 5.0)), NakedInterval((10.0, 15.0))], 2.5)</code></pre><p><strong>Shrinking</strong> — contract an interval inward from both ends:</p><pre><code class="language-julia hljs">shrink(NakedInterval((0.0, 10.0)), 2.0)
# NakedInterval((1.0, 9.0))</code></pre><p>When applied to a vector, intervals too short to survive the shrink are dropped.</p><p><strong>Shifting</strong> — translate an interval by an offset:</p><pre><code class="language-julia hljs">shift_interval(NakedInterval((0.0, 5.0)), 10.0)
# NakedInterval((10.0, 15.0))</code></pre><p><code>shift_interval</code> preserves marks on <code>MarkedInterval</code> and also works as a curried function:</p><pre><code class="language-julia hljs">shifter = shift_interval(10.0)
shifter(NakedInterval((0.0, 5.0)))  # NakedInterval((10.0, 15.0))</code></pre><p><strong>Overlap depth</strong> — compute how many intervals overlap at each position:</p><pre><code class="language-julia hljs">intervals = [NakedInterval((0.0, 5.0)),
             NakedInterval((3.0, 8.0)),
             NakedInterval((6.0, 10.0))]
levels = interval_levels(intervals)</code></pre><p><a href="../api/#EventIntervals.interval_levels-Union{Tuple{AbstractVector{&lt;:Interval{E, 1}}}, Tuple{E}} where E"><code>interval_levels</code></a> returns a vector of <code>MarkedInterval{Float64,Int}</code> where the mark is the overlap count. Assumes input is sorted by start time.</p><p><strong>Intersection and subintervals</strong> — find overlapping regions:</p><pre><code class="language-julia hljs">interval_intersect(NakedInterval((0.0, 5.0)), NakedInterval((3.0, 8.0)))
# NakedInterval((3.0, 5.0))

# Pairwise intersections between two sorted, non-overlapping vectors
interval_intersections([NakedInterval((0.0, 5.0)), NakedInterval((7.0, 10.0))],
                       [NakedInterval((3.0, 8.0))])
# [NakedInterval((3.0, 5.0)), NakedInterval((7.0, 8.0))]</code></pre><p><a href="../api/#EventIntervals.subinterval-Tuple{Interval, Real, Real}"><code>subinterval</code></a> validates that one interval is contained in another:</p><pre><code class="language-julia hljs">subinterval(NakedInterval((0.0, 10.0)), NakedInterval((2.0, 8.0)))
# NakedInterval((2.0, 8.0)) — validated as a subinterval</code></pre><p><strong>Relative coordinates</strong> — express an interval relative to a reference:</p><pre><code class="language-julia hljs">relative_interval(NakedInterval((5.0, 8.0)), NakedInterval((4.0, 10.0)))</code></pre><p><strong>Other utilities:</strong></p><pre><code class="language-julia hljs">check_overlap(NakedInterval((0.0, 5.0)), NakedInterval((3.0, 8.0)))  # true
is_subinterval(NakedInterval((2.0, 4.0)), NakedInterval((0.0, 10.0)))  # true
5.0 in NakedInterval((0.0, 10.0))  # true</code></pre><h2 id="Points"><a class="docs-heading-anchor" href="#Points">Points</a><a id="Points-1"></a><a class="docs-heading-anchor-permalink" href="#Points" title="Permalink"></a></h2><h3 id="NakedPoints"><a class="docs-heading-anchor" href="#NakedPoints">NakedPoints</a><a id="NakedPoints-1"></a><a class="docs-heading-anchor-permalink" href="#NakedPoints" title="Permalink"></a></h3><p><a href="#NakedPoints"><code>NakedPoints</code></a> stores a sorted vector of timestamps on a defined interval:</p><pre><code class="language-julia hljs">spikes = NakedPoints([0.5, 1.3, 2.1, 4.7, 5.2, 8.0, 9.1], NakedInterval((0.0, 10.0)))</code></pre><p>The constructor validates that points are sorted and fall within the interval. If not sorted, it will sort them:</p><pre><code class="language-julia hljs"># Unsorted input — automatically sorted
spikes = NakedPoints([9.1, 0.5, 4.7, 2.1, 1.3, 8.0, 5.2], NakedInterval((0.0, 10.0)))</code></pre><p>You can also construct from a tuple or two numbers for the interval bounds:</p><pre><code class="language-julia hljs">NakedPoints([1.0, 2.0, 3.0], (0.0, 5.0))
NakedPoints([1.0, 2.0, 3.0], 0.0, 5.0)</code></pre><p>Or let the interval be inferred from the data:</p><pre><code class="language-julia hljs">NakedPoints([1.0, 2.0, 3.0])  # interval = (1.0, 3.0)</code></pre><p><strong>Basic queries:</strong></p><pre><code class="language-julia hljs">count(spikes)           # 7
duration(spikes)        # 10.0
rate(spikes)            # 0.7 (count / duration)
bounds(spikes)          # (0.0, 10.0)
interval(spikes)        # NakedInterval((0.0, 10.0))

# Count and rate within a sub-range
count(spikes, 2.0, 6.0)   # 3
rate(spikes, 2.0, 6.0)    # 0.75</code></pre><p><strong>Extracting values:</strong></p><pre><code class="language-julia hljs">point_values(spikes)           # the underlying vector
point_values(spikes, 2.0, 6.0) # view of values in [2.0, 6.0]
nakedvalues(spikes)            # same as point_values for NakedPoints</code></pre><p><strong>Translation</strong> — shift all points and their interval by a constant offset:</p><pre><code class="language-julia hljs">shifted = translate(spikes, 100.0)
bounds(shifted)  # (100.0, 110.0)</code></pre><h3 id="VariablePoints"><a class="docs-heading-anchor" href="#VariablePoints">VariablePoints</a><a id="VariablePoints-1"></a><a class="docs-heading-anchor-permalink" href="#VariablePoints" title="Permalink"></a></h3><p><a href="#VariablePoints"><code>VariablePoints</code></a> pairs each timestamp with a mark (metadata value). Construct from a <code>NakedPoints</code> and a marks vector:</p><pre><code class="language-julia hljs">np = NakedPoints([1.0, 2.0, 3.0], NakedInterval((0.0, 5.0)))
vp = VariablePoints(np, [:a, :b, :c])</code></pre><p>Individual elements are <code>MarkedPoint</code> objects:</p><pre><code class="language-julia hljs">vp[1]  # MarkedPoint(1.0, :a)</code></pre><p><strong>Extracting values and marks:</strong></p><pre><code class="language-julia hljs">point_values(vp)            # (times_vector, marks_vector)
point_values(vp, 1.0, 2.5)  # (view of times, view of marks) in range
get_mark(vp)                 # the full marks vector</code></pre><p>All <code>Points</code> operations (<code>count</code>, <code>rate</code>, <code>duration</code>, <code>bounds</code>, <code>translate</code>) work on <code>VariablePoints</code>.</p><h3 id="SubPoints"><a class="docs-heading-anchor" href="#SubPoints">SubPoints</a><a id="SubPoints-1"></a><a class="docs-heading-anchor-permalink" href="#SubPoints" title="Permalink"></a></h3><p><a href="#SubPoints"><code>SubPoints</code></a> is a lazy, zero-copy view of a <code>Points</code> collection restricted to a sub-interval:</p><pre><code class="language-julia hljs">spikes = NakedPoints([0.5, 1.3, 2.1, 4.7, 5.2, 8.0, 9.1], NakedInterval((0.0, 10.0)))
trial = SubPoints(spikes, NakedInterval((2.0, 6.0)))

count(trial)     # 3 — only points in [2.0, 6.0]
rate(trial)      # 0.75
duration(trial)  # 4.0</code></pre><p>The constructor validates that the sub-interval is contained within the parent:</p><pre><code class="language-julia hljs">SubPoints(spikes, NakedInterval((2.0, 6.0)))  # OK
SubPoints(spikes, (2.0, 6.0))                  # tuple form also works
SubPoints(spikes, 2.0, 6.0)                    # two-argument form</code></pre><p>Nesting <code>SubPoints</code> flattens automatically — the inner view references the original data, not the intermediate view.</p><p><a href="../api/#EventIntervals.maybe_subpoints-Tuple{Points, Interval}"><code>maybe_subpoints</code></a> returns a <code>SubPoints</code> if the interval intersects, or <code>nothing</code> if it doesn&#39;t:</p><pre><code class="language-julia hljs">maybe_subpoints(spikes, NakedInterval((2.0, 6.0)))   # SubPoints(...)
maybe_subpoints(spikes, NakedInterval((20.0, 30.0)))  # nothing</code></pre><h3 id="Mark-Operations"><a class="docs-heading-anchor" href="#Mark-Operations">Mark Operations</a><a id="Mark-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Mark-Operations" title="Permalink"></a></h3><p>Marks can be stacked and unstacked using tuple nesting:</p><pre><code class="language-julia hljs">p = NakedPoint(1.0)
mp = push_mark(p, :neuron_A)      # MarkedPoint(1.0, :neuron_A)
mp2 = push_mark(mp, 42)           # MarkedPoint(1.0, (42, :neuron_A))
inner, outer_mark = pop_mark(mp2)  # (MarkedPoint(1.0, (:neuron_A,)), 42)</code></pre><p><a href="../api/#EventIntervals.pop_marks-Tuple{VariablePoints}"><code>pop_marks</code></a> strips the outermost mark from all points in a <code>VariablePoints</code>.</p><h3 id="Joining-Points"><a class="docs-heading-anchor" href="#Joining-Points">Joining Points</a><a id="Joining-Points-1"></a><a class="docs-heading-anchor-permalink" href="#Joining-Points" title="Permalink"></a></h3><p><a href="../api/#EventIntervals.join_points-Union{Tuple{Points{&lt;:Any, &lt;:Any, &lt;:Any, P}}, Tuple{P}} where P&lt;:NakedPoint"><code>join_points</code></a> merges multiple point collections. The result&#39;s interval is the union of the inputs:</p><pre><code class="language-julia hljs">a = NakedPoints([1.0, 3.0], NakedInterval((0.0, 5.0)))
b = NakedPoints([2.0, 7.0], NakedInterval((0.0, 10.0)))
joined = join_points(a, b)
# 4 points on interval (0.0, 10.0), sorted</code></pre><p>Works for both naked and marked points, and accepts any number of arguments:</p><pre><code class="language-julia hljs">join_points(a, b, c)  # merges three collections</code></pre><h3 id="Intersecting-Point-Collections"><a class="docs-heading-anchor" href="#Intersecting-Point-Collections">Intersecting Point Collections</a><a id="Intersecting-Point-Collections-1"></a><a class="docs-heading-anchor-permalink" href="#Intersecting-Point-Collections" title="Permalink"></a></h3><p><a href="../api/#EventIntervals.points_intersects-Tuple{AbstractVector{&lt;:Points}, AbstractVector{&lt;:Points}}"><code>points_intersects</code></a> finds the intersection of two vectors of <code>Points</code> — restricting each collection to only the time ranges where both have coverage:</p><pre><code class="language-julia hljs">pts1 = [NakedPoints([1.0, 2.0], NakedInterval((0.0, 5.0)))]
pts2 = [NakedPoints([3.0, 6.0], NakedInterval((2.0, 8.0)))]
sub1, sub2 = points_intersects(pts1, pts2)</code></pre><p><a href="../api/#EventIntervals.interval_intersections_subpoints-Union{Tuple{P}, Tuple{M}, Tuple{E}, Tuple{AbstractVector{P}, AbstractVector{&lt;:Interval{E}}}} where {E, M, P&lt;:(Points{E, 1, &lt;:Any, M})}"><code>interval_intersections_subpoints</code></a> is the lower-level function that intersects a vector of <code>Points</code> with a vector of <code>Interval</code> objects, returning <code>SubPoints</code> views.</p><h3 id="Downsampling"><a class="docs-heading-anchor" href="#Downsampling">Downsampling</a><a id="Downsampling-1"></a><a class="docs-heading-anchor-permalink" href="#Downsampling" title="Permalink"></a></h3><p><a href="../api/#EventIntervals.pp_downsamp-Union{Tuple{RetType}, Tuple{M}, Tuple{E}, Tuple{Points{E, 1, &lt;:Any, M}, Any, Any, Any}, Tuple{Points{E, 1, &lt;:Any, M}, Any, Any, Any, Function}, Tuple{Points{E, 1, &lt;:Any, M}, Any, Any, Any, Function, Type{RetType}}} where {E, M, RetType}"><code>pp_downsamp</code></a> merges points that are closer together than a given resolution, useful for reducing dense event data for visualization:</p><pre><code class="language-julia hljs">spikes = NakedPoints([1.0, 1.1, 1.2, 5.0, 5.05, 9.0], NakedInterval((0.0, 10.0)))
ds = pp_downsamp(spikes, 0.0, 10.0, 0.5)</code></pre><p>Points within <code>resolution</code> of each other are merged using a merge function. The default <a href="../api/#EventIntervals.pt_merge-Tuple{AbstractVector{&lt;:NakedPoint{&lt;:Number}}}"><code>pt_merge</code></a> averages timestamps (and marks, if present). <a href="../api/#EventIntervals.pt_extent_merge-Tuple{AbstractVector{&lt;:MarkedPoint{&lt;:Number, &lt;:Number}}}"><code>pt_extent_merge</code></a> preserves the extent (min, max) of merged points as an additional mark.</p><p>Each merged point gets a count pushed onto its mark stack, recording how many original points were combined.</p><h3 id="Aggregate-Rate"><a class="docs-heading-anchor" href="#Aggregate-Rate">Aggregate Rate</a><a id="Aggregate-Rate-1"></a><a class="docs-heading-anchor-permalink" href="#Aggregate-Rate" title="Permalink"></a></h3><p><code>rate</code> can also be computed over a vector of <code>Points</code>:</p><pre><code class="language-julia hljs">rate([trial_spikes_1, trial_spikes_2, trial_spikes_3])
# total spike count across all trials / total duration</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../api/">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 3 February 2026 01:40">Tuesday 3 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
